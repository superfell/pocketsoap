<Library>
	<Description>Welcome to the pocketSOAP reference.</Description>
	<CoClasses>
		<CoClass name="CoEnvelope">
			<Short>This represents a SOAP Envelope, its a central part of any pocketSOAP application</Short>
			<Links/>
			<ProgID>pocketSOAP.Envelope.2</ProgID>
			<Description>The Envelope object represents a SOAP envelope and is the major object you'll use in a pocketSOAP application.
The Envelope object allows you build a SOAP envelope and populate the methodName and parameter information, serialize the resulting
Envelope to XML, and to parse an XML Envelope back into its constituent parts. The Envelope object supports both SOAP 1.1 and SOAP 1.2.
Using the CoEnvelope CLSID or the PocketSOAP.Envelope.2 or PocketSOAP.Envelope.11 ProgIds will create an envelope configured for SOAP 1.1.
Using the CoEnvelope12 CLSID or PocketSOAP.Envelope.12 ProgId will create an envelope configured for SOAP 1.2.
</Description>
			<HowToInstantiate>
set e = CreateObject("pocketSOAP.Envelope.2")
</HowToInstantiate>
			<SampleCode>
				<pre>dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "getQuote", "urn:xmethods-delayed-quotes"
e.parameters.create "Symbol", "AMD"

dim t
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.Send "http://services.xmethods.net/soap", e.serialize
e.parse t
wscript.echo "Quote for AMD = " &amp; e.parameters.item(0).value
</pre>
			</SampleCode>
		</CoClass>
		<CoClass name="HTTPTransport">
			<Short>A HTTP 1.1 Transport with support for persistent connections, compression, cookies, redirects, proxies, proxy authentication, server authentication and SSL</Short>
			<Links/>
			<ProgID>pocketSOAP.HTTPTransport.2</ProgID>
			<Description>The HTTPTransport object provides the HTTP transport for pocketSOAP, you use it in conjunction with the
Envelope object to make SOAP calls over HTTP. It includes support for HTTP 1.1 persistent connections, compression, proxies, 
server authentication, proxy authentication, session cookies, redirects and SSL.
</Description>
			<HowToInstantiate>set t = CreateObject("pocketSOAP.HTTPTransport.2")</HowToInstantiate>
			<SampleCode>
				<pre>dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "getQuote", "urn:xmethods-delayed-quotes"
e.parameters.create "Symbol", "AMD"

dim t
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.SOAPAction = ""
t.SetProxy "proxy.example.org", 8080
t.ProxyAuthentication "simonfell", "password"
t.Send "http://services.xmethods.net/soap", e.serialize
e.parse t
wscript.echo "Quote for AMD = " &amp; e.parameters.item(0).value
</pre>
			</SampleCode>
		</CoClass>
		<CoClass name="CoSoapNode">
			<Short>This represents a node within a SOAP envelope</Short>
			<Links/>
			<ProgID>pocketSOAP.Node.1</ProgID>
			<Description>The Node object represents a single node [such as a parameter] with the SOAP envelope. It holds information
such as the nodes value, its Xml Type. It also contains a collection of child nodes.l</Description>
			<HowToInstantiate>
You can create a stand alone Node object with<BR/>
set n = CreateObject("pocketSOAP.Node.1")<BR/>
' do something with n<BR/>
however typically you create new nodes by using the create function on the nodes collection class to quickly create a new node
in the correct place.
</HowToInstantiate>
			<SampleCode>
				<pre>dim e, h
set e = CreateObject("pocketSOAP.Envelope.2")
' get 3 quotes in one go
e.setMethod "getQuote", "http://quotes.org/"
e.parameters.create "Symbol", "AMD"
e.parameters.create "Symbol", "MSFT"
e.parameters.create "Symbol", "INTC"

' create a header node with our user info in
set h = e.headers.create ("Credentials", "","http://quotes.org/")
h.nodes.create "username", "simonfell"
h.nodes.create "password", "password"

</pre>
			</SampleCode>
		</CoClass>
		<CoClass name="CoSerializerFactory">
			<Short>The Serializer Factory maintains the mappings between SOAP and COM</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerFactory.1</ProgID>
			<Description>The serializer factory is responsible for maintaining the mapping data between COM types and SOAP types, the
serializer factory exposes methods in the ISerializerFactory method to make finding the correct [de]serializers easy. You
can configure the serializer factory through the ISerializerFactoryConfig interface.
</Description>
			<HowToInstantiate><![CDATA[
You can create a stand alone instance of the serializer Factory with<BR/>
set sf = CreateObject("pocketSOAP.SerializerFactory.1")<BR/><BR/>
this is useful if you have extensive configuration changes to make, you can create a single instance of the serializer factory,
make the calls to ISerializerFactoryConfig to get it configured as you need it, then tell each Envelope object to use this 
serializer factory rather than the default one by calling ISOAPEnvelope::putref_SerializerFactory(...). If you don't tell
the Envelope to use a particular serializer factory, then it will create and use the default serializer factory [this is fine in 
many cases]
]]></HowToInstantiate>
			<SampleCode>
dim sf, e
set sf = CreateObject("pocketSOAP.SerializerFactory.1")

' we are talking to an old endpoint, and have to use the old 1999 schema version
sf.PrimarySchema = "http://www.w3.org/1999/XMLSchema"

' use the scripting friendly mode [all arrays are arrays of variants]
sf.SetConfig ( sfcScripting )

' if we receive an untyped element call memorysize, treat is as an xsd:int [a signed 32 bit number]
sf.ElementMapping "memorysize", "", "http://www.w3.org/1999/XMLSchema", "int"

set e = CreateObject("pocketSOAP.Envelope.2")
' tell this envelope to use our serializer factory config we just built, rather than the default
set e.SerializerFactory = sf
</SampleCode>
		</CoClass>
		<CoClass name="CoSerializerSimple">
			<Short>A Serializer object that handles most simple types</Short>
			<Links/>
			<ProgID>pocketSOAP.SimpleSerializer.1</ProgID>
			<Description>This serializer object handles serializing and deserializing most simple types</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerArray">
			<Short>A Serializer object for handling Arrays</Short>
			<Links/>
			<ProgID>pocketSOAP.ArraySerializer.1</ProgID>
			<Description>This serializer serializes COM arrays (SAFEARRAYS) to SOAP encoded arrays</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoDeserializerArray">
			<Short>A De-Serializer object for de-serializing SOAP arrays</Short>
			<Links/>
			<ProgID>pocketSOAP.ArrayDeSerializer.1</ProgID>
			<Description>This deserializer will deserialize SOAP encoded arrays to COM arrays (SAFEARRAYS)</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerNode">
			<Short>A generic serializer for the CoSoapNode object</Short>
			<Links/>
			<ProgID>pocketSOAP.NodeSerializer.1</ProgID>
			<Description>A [de]serializer for the CoSOAPNode object</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerB64">
			<Short>A Base64 encoding serializer</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerB64.1</ProgID>
			<Description>A [de]serializer for base64 encoded data</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerDate">
			<Short>A Date (ISO8601 format serializer)</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerDate.1</ProgID>
			<Description>a [de]serializer for Date/Times (ISO8601 format)</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerPB">
			<Short>The PropertyBag serializer, this can be used to [de]serialization any COM object that supports IPeristPropertyBag</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerPB.1</ProgID>
			<Description>A [de]serializer for maps between COM PropertyBags and SOAP encoded complex types</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerBoolean">
			<Short>The serializer for handling booleans</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerBoolean.1</ProgID>
			<Description>A [de]serializer for booleans</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="RawTcpTransport">
			<Short>A simple TCP based transport that works with the SOAP::Lite TcpServer option.</Short>
			<Links/>
			<ProgID>pocketSOAP.RawTCPTransport</ProgID>
			<Description>
			This is a simple TCP transport, that works with the SOAP::Lite TcpServer option. This is a much simpler transport
			that the HTTP transport.
		</Description>
			<HowToInstantiate>Create this transport with <b>CreateObject("pocketSOAP.RawTcpTransport")</b></HowToInstantiate>
			<SampleCode>
				<![CDATA[
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "test", "http://www.soaplite.com/ClearingHouse"

set t = CreateObject("pocketSOAP.RawTCPTransport")
t.timeout = 5000
t.send "rawtcp://some.server.com:8002", e.serialize
e.parse t

wscript.echo e.parameters.item(0).value
]]>
			</SampleCode>
		</CoClass>
		<CoClass name="CoSerializerNull">
			<Short>A serializer for NULL's</Short>
			<Links/>
			<ProgID>PocketSOAP.SerializerNull.1</ProgID>
			<Description>A serializer for NULL values, it generates a xsi:nil='1' or xsi:nul='true' attribute (depending what version of XML Schema is in use)</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerHexBin">
			<Short>A [de]serializer that maps between COM arrays of Bytes and the xsd:hexBinary XML Schema type</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerHexBin.1</ProgID>
			<Description>A [de]serializer that maps between COM arrays of Bytes and the xsd:hexBinary XML Schema type</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoQName">
			<Short>An COM object that represents an XML QName (Qualified Name)</Short>
			<Links/>
			<ProgID>pocketSOAP.QName.1</ProgID>
			<Description>This object represents an XML QName (Qualified Name), it basically consists of two properties the Namespace URI and the localname</Description>
			<HowToInstantiate></HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoSerializerQName">
			<Short>A [de]serializer for the CoQName object</Short>
			<Links/>
			<ProgID>pocketSOAP.SerializerQName.1</ProgID>
			<Description>A [de]serializer that maps between the CoQName object and a XML QName</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoInterfaceFinder">
			<Short>This is a helper class, that at runtime tries to find the default Interface IID for a given object.</Short>
			<Links/>
			<ProgID>pocketSOAP.InterfaceFinder.1</ProgID>
			<Description>This is a helper class, that at runtime tries to find the default Interface IID for a give object. This
		is typically used when configuring the serializerFactory for VB based objects, as its not possible to dictate what the
		Inteface IID for a VB generated interface should be. The WSDL wizard uses this in the code it generates to configure
		the serializer factory.</Description>
			<HowToInstantiate>
		Create a new instance via CreateObject, New or CoCreateInstance.
		</HowToInstantiate>
			<SampleCode>
Set m_sf = New CoSerializerFactory
Dim i As New CoInterfaceFinder
m_sf.Serializer i.DefaultIID("XSpaceService.AuthIDPassword"), "AuthIDPassword", "http://xmethods.net/common", "XSpaceService.s_AuthIDPassword"
		</SampleCode>
		</CoClass>
		<CoClass name="CoSerializerArray12">
			<Short>This is a serializer for handling SOAP 1.2 arrays</Short>
			<Links/>
			<ProgID>PocketSOAP.ArraySerializer12</ProgID>
			<Description>This is a serializer for handling SOAP 1.2 arrays</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoDeserializerArray12">
			<Short>This is a deserializer for handling SOAP 1.2 arrays</Short>
			<Links/>
			<ProgID>pocketSOAP.ArrayDeSerializer12</ProgID>
			<Description>This is a deserializer for handling SOAP 1.2 arrays.</Description>
			<HowToInstantiate>Typically, you don't create the serializer directly, rather you call SerializeNode or
			SerializeValue on the serializerOutput, and it will create the correct serializer as needed.</HowToInstantiate>
			<SampleCode></SampleCode>
		</CoClass>
		<CoClass name="CoEnvelope12">
			<Short>A SOAP 1.2 Envelope</Short>
			<Links/>
			<ProgID>pocketSOAP.Envelope.12</ProgID>
			<Description>This is a SOAP Envelope that's already configure to be in SOAP 1.2 format</Description>
			<HowToInstantiate>Call CoCreateInstance (or CreateObject etc) using the CLSID of ProgID.</HowToInstantiate>
			<SampleCode><![CDATA[
dim env, t
set env = CreateObject("PocketSOAP.Envelope.12")
env.SetMethod "echoString", "http://example.org/ts-tests"
env.Parameters.Create "inputString", "Hello World"

set t = CreateObject("PocketSOAP.HTTPTransport")
t.Send "http://www.whitemesa.net/soap12/test-rpc", env
env.Parse t
]]></SampleCode>
		</CoClass>
	</CoClasses>
	<Interfaces>
		<Interface name="ISOAPTransport">
			<Short>This is the standard interface all transport objects should implement</Short>
			<Links/>
			<Methods>
				<Method name="Send">
					<Short>Send the Envelope to the specified endpoint</Short>
					<Links/>
					<Parameters>
						<Parameter name="endpoint">The endpoint URL, e.g. http://soap.4s4c.com/ilab/soap.asp , rawtcp://example.org:8002</Parameter>
						<Parameter name="Envelope">The SOAP Envelope to send [normally generated by calling ISOAPEnvelope::Serialize()]</Parameter>
					</Parameters>
					<Description>This takes the SOAP Envelope and sends it to the endpointURL, exactly what that entails depends on the transport object being used.
The transport object is responsible for transcoding the Envelope from the supplied UTF-16 format, to whatever is a suitable format for the transport
medium [e.g. the HTTP transports transcodes to UTF-8 before sending the request]</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode><![CDATA[
dim t
set t = CreateObject("pocketSOAP.HTTPTransport")
t.Send "http://example.org:8080/soap.jsp", e.serialize
e.parse t
]]>
					</SampleCode>
				</Method>
				<Method name="Receive">
					<Short>Called after Send, it returns the response to the request</Short>
					<Links/>
					<Parameters>
						<Parameter name="characterEncoding">The characterEncoding of the response, if the transport can detect it [e.g. UTF-8]</Parameter>
						<Parameter name="Envelope">An array of bytes representing the response SOAP envelope</Parameter>
					</Parameters>
					<Description><![CDATA[
Once send has been called, the client code can call Receive to retrieve the response to the request.
The response is typically in the character encoding that the server returned, however if the server returns a response
in a character encoding that's not supported by the Envelope class, then the transport object can transcode the response
to one of the supported character encodings. <br>
The case where the transport specification indicates that the transport can override the character encoding indicated in the XML payload 
[such as HTTP], the transport can set the characterEncoding to the relevant value, the client code should then treat the response that
character encoding.<br>
Typically you don't call receive directly, calling ISOAPEnvelope::Parse and passing it a transport object, will call receive and handle
the character encoding issues for you.
]]>
					</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim t
set t= CreateObject("pocketSOAP.HTTPTransport")
t.send "http://example.org/", e.serialize
e.parse t
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This is the standard transport interface, all transport objects are required to implement this interface.</Description>
			<WhenToImpl>Implement this interface if you are building a new transport object for use with pocketSOAP</WhenToImpl>
			<WhenToCall>Call this interface to send/receive your SOAP envelope to the required destination</WhenToCall>
		</Interface>
		<Interface name="IHTTPTransport">
			<Short>This is the standard interface all HTTP based transport objects should implement [in addition to ISOAPTransport]</Short>
			<Links/>
			<Methods>
				<Method name="SOAPAction">
					<Short>Gets/Sets the SOAPAction header value.</Short>
					<Links/>
					<Parameters/>
					<Description>This controls the value of the SOAPAction HTTP header, SOAP 1.1 requires that a SOAPAction header is always sent, in 
the event that there's no call to SOAPAction before Send is called, an empty SOAPAction header is sent. If you call SOAPAction 
and set it to "", then a SOAPAction: "" header is sent [these two have specific meanings, as defined in the SOAP spec]
</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim t
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.send "http://example.org/", e.serialize
' this sends this HTTP header
SOAPAction:

t.SOAPAction = ""
t.send "http://example.org/", e.serialize
' this sends this HTTP header
SOAPAction: ""

t.SOAPAction = "http://example.org/add"
t.send "http://example.org/", e.serialize
' this sends this HTTP header
SOAPAction: "http://example.org/add"

]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>IHTTPTransport is a standard interface that signals that the transport object provides HTTP semantics.</Description>
			<WhenToImpl>Implement this interface if you are writing your own transport object, that uses the HTTP semantics.</WhenToImpl>
			<WhenToCall>You typically make a call to set the SOAPAction before calling ISOAPTransport::Send</WhenToCall>
		</Interface>
		<Interface name="IHTTPTransportAdv">
			<Short>This interface allows access to the advanced features of the pocketSOAP HTTP transport object</Short>
			<Links/>
			<Methods>
				<Method name="Timeout">
					<Short>This get/sets the current timeout value [in milliseconds].</Short>
					<Links/>
					<Parameters/>
					<Description>This get/sets the current timeout value [in milliseconds]. The same value is used for both the send and receive timeout. The default is 15 seconds.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
set t = CreateObject("pocketSOAP.HTTPTRansport.2")
t.SOAPAction = "http://soapinterop.org/"
t.Timeout = 30000
t.Send "http://soap.4s4c.com/ilab/soap.asp", test1Envelope
....
</SampleCode>
				</Method>
				<Method name="SetProxy">
					<Short>Calling SetProxy enable the use of a proxy server for subsequent calls to Send/Receive</Short>
					<Links/>
					<Parameters>
						<Parameter name="ProxyServer">the Name or IP address of the proxy server to use</Parameter>
						<Parameter name="ProxyPort">the Port number to connect to on the proxy server</Parameter>
					</Parameters>
					<Description>This enables the use of a proxy server for outgoing HTTP(S) connections.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim t 
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.SetProxy "proxy.domain.com", 8080
]]>
					</SampleCode>
				</Method>
				<Method name="NoProxy">
					<Short>Disable Proxy Server support, subsequent calls to Send/Receive will make direct connections</Short>
					<Links/>
					<Parameters/>
					<Description>This disables the use of a proxy server [previously enabled via a call to SetProxy].</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim t
set t =CreateObject("pocketSOAP.HTTPTransport.2")
' proxy through proxy.domain.com:8080
t.SetProxy "proxy.domain.com", 8080
t.send "http://example.org", e.serialize

' now make direct connections rather than proxying
t.NoProxy
t.send "http://example.org", e.serialize
]]>
					</SampleCode>
				</Method>
				<Method name="Authentication">
					<Short>Sets the server authentication credentials</Short>
					<Links/>
					<Parameters>
						<Parameter name="username">The username to use</Parameter>
						<Parameter name="password">The password for the username</Parameter>
					</Parameters>
					<Description>This sets the authentication credentials for the destination server. Only basic authentication is currently supported</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim t
set t = CreateObject("pocketSOAP.HTTPTransport.2")
' connect to example.org with these credentials
t.Authentication "simonfell", "password"
t.send "http://example.org/", e.serialize
]]>
					</SampleCode>
				</Method>
				<Method name="ProxyAuthentication">
					<Short>Sets the authentication credentials for connecting to the proxy server</Short>
					<Links/>
					<Parameters>
						<Parameter name="username">The username to use</Parameter>
						<Parameter name="password">The password for the username</Parameter>
					</Parameters>
					<Description>This sets the authentication credentials for the connection to the proxy server. Only basic authentication is currently supported.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim t 
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.SetProxy "proxy.domain.com", 8080
t.ProxyAuthentication "simonfell", "password"
t.send "http://example.org", 8080
]]>
					</SampleCode>
				</Method>
				<Method name="StatusCode">
					<Short>Returns the last HTTP status code received [e.g. 200]</Short>
					<Links/>
					<Parameters/>
					<Description>Following a call to ISOAPTransport::Receive, the StatusCode property will return the last HTTP status code returned from the server</Description>
					<ReturnValue>Any valid HTTP status code [e.g. 200]</ReturnValue>
					<SampleCode><![CDATA[
dim t
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.send "http://example.org/", e.serialize
' note that parse will call t.receive to get the results
e.parse t
wscript.echo "Last HTTP status code = " & t.StatusCode
]]>
					</SampleCode>
				</Method>
				<Method name="MaxRedirectDepth">
					<Short>Controls the maximum number of HTTP redirects to follow before stopping</Short>
					<Links/>
					<Parameters/>
					<Description>The HTTPTransport will follow redirects returned from the server, until the number of redirects equals MaxRedirectDepth for a single request.
This defaults to 5. You can set this to 0 to disable redirects.</Description>
					<ReturnValue>The current value of the MaxRedirectDepth property</ReturnValue>
					<SampleCode><![CDATA[
dim t 
set t = CreateObject("pocketSOAP.HTTPTransport.2")
' disable redirects
t.MaxRedirectDepth = 0
t.send "http://example.org/", e.serialize
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This inteface allows access to the HTTP specific properties and configuration values.</Description>
			<WhenToImpl>Implement this if you are writing a HTTP transport</WhenToImpl>
			<WhenToCall>Call this interface to configure HTTP specific properties of the HTTP transport.</WhenToCall>
		</Interface>
		<Interface name="ISOAPNamespaces">
			<Short>This interface allows access to the current Namespace definitions during [de]serialization</Short>
			<Links/>
			<Methods>
				<Method name="GetPrefixForURI">
					<Short>Given a namespace URI returns the current prefix for it, a prefix is automatically generated if needed</Short>
					<Links/>
					<Parameters>
						<Parameter name="NamespaceURI">The namespace URI e.g. urn:xmethods-delayed-quotes or http://soapinterop.org/xsd</Parameter>
						<Parameter name="prefix">This returns the prefix associated with the URI</Parameter>
					</Parameters>
					<Description>This will search the currently active namespaces for the specified namespace URI, and return its current prefix. 
If not found it will create a new prefix and add it as an active namespace. Typically you don't need to call this, as the
methods on the ISerializerOutput interface all take namespace URI's and handle the prefix mappings for you.</Description>
					<ReturnValue>The results prefix for this namespace</ReturnValue>
					<SampleCode><![CDATA[
STDMETHODIMP CMySerializer::Serialize( /*[in]*/ VARIANT *val, ISerializerContext * ctx, /*[in]*/ ISerializerOutput * dest )
{
	if ( val->vt != VT_BSTR ) return E_UNEXPECTED ;
	CComPtr<ISOAPNamespaces> n ;
	ctx->get_Namespaces(&n) ;
	CComBSTR prefix ;
	ctx->GetPrefixForURI ( CComBSTR(L"http://schemas.pocketsoap.com/samples/"), &prefix ) ;
	dest->WriteText(prefix) ;
	dest->WriteText(CComBSTR(L":")) ;
	dest->WriteText(val->bstrVal) ;
	return ;
}
]]></SampleCode>
				</Method>
				<Method name="GetURIForPrefix">
					<Short>Finds the namespace URI associated with a particular prefix. Its unlikely that you'll need to call this, as the de-serialization model
has already mapped the prefixes back to URIs</Short>
					<Links/>
					<Parameters>
						<Parameter name="prefix">The prefix to look for</Parameter>
						<Parameter name="NamespaceURI">The namespace URI current associated with that prefix</Parameter>
					</Parameters>
					<Description>Given a particular namespace prefix, return the namespace URI currently associated with it.</Description>
					<ReturnValue>The namespace URI is returned if the prefix is found, otherwise the error E_INVALIDARG is returned.</ReturnValue>
					<SampleCode><![CDATA[

]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface allows access to the current namespace context during [de]serialization</Description>
			<WhenToImpl>There is a standard system implementation of this, you shouldn't need to implement it.</WhenToImpl>
			<WhenToCall>Call this interface when handling namespaces. Many of the [de]serialization interfaces work directly with namespace URI's so its
unlikely that you'll need to call this directly.</WhenToCall>
		</Interface>
		<Interface name="ISOAPEnvelope">
			<Short>The primary interface to the SOAP Envelope object</Short>
			<Links/>
			<Methods>
				<Method name="ThrowFaults">
					<Short>This property controls if SOAP faults are automatically converted to COM faults or not</Short>
					<Links/>
					<Parameters/>
					<Description>When ThrowFaults is set to VARIANT_TRUE [the default] the Envelope object will automatically check any SOAP message it parses [via the Parse method]
to see if it contains a SOAP fault, in the event that the SOAP message is indeed a SOAP Fault, it will translate the SOAP Fault to a COM error and return that error.
</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
set e = CreateObject("pocketSOAP.Envelope.2")
set t = CreateObject("pocketSOAP.HTTPTransport.2")
....
t.send "http://example.org/", e.serialize
e.ThrowFaults = true
' if the response Message contains a SOAP Fault, the call to Parse will fail with the SOAP Fault error
' if ThrowFaults was set to false, the call to Parse will succeed even if the SOAP message is a SOAP Fault.
e.Parse t
</SampleCode>
				</Method>
				<Method name="URI">
					<Short>This property gets/sets the namespace URI for the methodName</Short>
					<Links/>
					<Parameters/>
					<Description><![CDATA[
This allows you to get/set the namespace URI associated with the methodName element, e.g.<BR>
&lt;s:Envelope xmlns:s="'http://schemas.xmlsoap.org/soap/envelope/&gt;<BR>
&lt;s:Body&gt;<BR>
&lt;m:AddNumbers <b>xmlns:m="http://example.org/"</b>&gt;<BR>
&lt;a&gt;10&lt;/a&gt;<BR>
&lt;b&gt;20&lt;/b&gt;<BR>
&lt;/m:AddNumbers&gt;<BR>
&lt;/s:Body&gt;<BR>
&lt;/s:Envelope&gt;<BR>
<BR>
In this example 'http://example.org/' is the methodName namespace.
]]>
					</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e, t
set e = CreateObject("pocketSOAP.ENvelope.2")
e.URI = "http://example.org/"
e.MethodName = "AddNumbers"
...
</SampleCode>
				</Method>
				<Method name="MethodName">
					<Short>This property gets/sets the methodName</Short>
					<Links/>
					<Parameters/>
					<Description>This gets/sets the methodName for the generated SOAP message, this typically maps to the remote function you are trying to call</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e, t
set e = CreateObject("pocketSOAP.ENvelope.2")
e.URI = "http://example.org/"
e.MethodName = "AddNumbers"
...
</SampleCode>
				</Method>
				<Method name="EncodingStyle">
					<Short>Controls the EncodingStyle URI property in the envelope, this defaults to the standard section 5 encoding URI of http://schemas.xmlsoap.org/soap/encoding/</Short>
					<Links/>
					<Parameters/>
					<Description>
The EncodingStyle attribute is used in the SOAP message to identify what encoding model was used to generate the message, at this point in time there is 
only one standard encodingStyle defined [typically called section 5, as it is defined in section 5 of the SOAP 1.1 spec]. This property defaults to the
section 5 encoding style URI of http://schemas.xmlsoap.org/soap/encoding/ . You may want to set this to an empty string if the endpoint you are calling
is using literal XML rather than section 5.
</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
' prints http://schemas.xmlsoap.org/soap/encoding/
wscript.echo e.EncodingStyle
e.EncodingStyle = ""

</SampleCode>
				</Method>
				<Method name="SetMethod">
					<Short>This allows you to set the MethodName and Namespace URI in one go</Short>
					<Links/>
					<Parameters>
						<Parameter name="methodName">The methodName to call e.g. getQuote</Parameter>
						<Parameter name="methodNameNamespaceURI">The method namespace URI e.g. urn:xmethods-delayed-quotes</Parameter>
					</Parameters>
					<Description>This sets both the methodName and the Namespace URI in a single call.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "AddNumbers", "http://example.org/"
...
</SampleCode>
				</Method>
				<Method name="Parse">
					<Short>This parses a SOAP Envelope</Short>
					<Links/>
					<Parameters>
						<Parameter name="Envelope">The SOAP Envelope to parse, this can either be a string [VT_BSTR], an array of bytes [VT_UI1|VT_ARRAY] or an object that implements ISOAPTransport, ISOAPTransport2 or ISwATransport [in which case Receive will be called]</Parameter>
						<Parameter name="characterEncoding">The character encoding of the envelope, leave this as an empty string to have the parser work it out from the XML, or set it to a specific value for the cases where the transport can override the XML character encoding [such as HTTP]</Parameter>
					</Parameters>
					<Description>
This takes a SOAP Envelope and parses it back into the COM object model. If ThrowFaults is set to VARIANT_TRUE, then following successful completion of the parsing 
step, the message is checked to see if its a SOAP Fault, and if so, the fault is mapped to a COM error and returned.
</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e , t
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "echoString", "http://soapinterop.org/"
e.Parameters.Create "inputString", "Hello World"
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.send "http://soap.4s4c.com/ilab/soap.asp", e.serialize

e.parse t
wscript.echo e.parameters.item(0).value
</SampleCode>
				</Method>
				<Method name="Serialize">
					<Short>Take the current state of the Envelope and serialize to a XML string</Short>
					<Links/>
					<Parameters>
						<Parameter name="soapMsg">The resulting XML, as this is a BSTR and is therefore Unicode, so this is always UTF-16 encoded</Parameter>
					</Parameters>
					<Description>
This takes the current state of the Envelope object model, and serializes it as an XML/SOAP message. 
The transport object can choose to transcode from the supplied UTF-16 supplied data to an encoding more suitable for transport [typically UTF-8]
</Description>
					<ReturnValue>The serialized envelope as a string</ReturnValue>
					<SampleCode>
dim e , t
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "echoString", "http://soapinterop.org/"
e.Parameters.Create "inputString", "Hello World"
set t = CreateObject("pocketSOAP.HTTPTransport.2")

wscript.echo "Request XML" + vbCRLF + e.serialize
t.send "http://soap.4s4c.com/ilab/soap.asp", e.serialize
e.parse t
wscript.echo e.parameters.item(0).value

</SampleCode>
				</Method>
				<Method name="Headers">
					<Short>This returns a Nodes collection object that represents the current SOAP Headers</Short>
					<Links/>
					<Parameters/>
					<Description>
This returns a nodes collection that represents the child nodes of the SOAP Header element. The Header element is the key extensibility point in SOAP
</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e, hdr
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "getQuote", "http://stocks.com/"
' create a new header element, with the authentication info in
set hdr = e.Headers.Create ("Authentication", "", "http://stocks.com/auth/") 
' now create the child elements for it
hdr.Nodes.Create "username", "simonfell"
hdr.Nodes.Create "password", "password"

' create the rest of the message as normal
e.Parameters.Create "Symbol", "AMD"
...
</SampleCode>
				</Method>
				<Method name="Body">
					<Short>This returns a Nodes collection object that represents the current SOAP Body</Short>
					<Links/>
					<Parameters/>
					<Description>This returns a Nodes collection that represents the child nodes of the SOAP Body element. Typically you would use the Parameters collection instead
as that directly refers to the method parameters and takes into accounts other serialization roots within the body.</Description>
					<ReturnValue>
					</ReturnValue>
					<SampleCode>
dim e, t
set e = CreateObject("pocketSOAP.Envelope.2")
...
e.parse t
wscript.echo "# body nodes = " &amp; e.Body.Count
</SampleCode>
				</Method>
				<Method name="Parameters">
					<Short>This returns a Nodes collection object that represent the current Parameters [i.e. the children of the methodName element]</Short>
					<Links/>
					<Parameters/>
					<Description>This accesses the parameters collection [i.e. the collection of nodes that are children of the methodName element]. This correctly takes into
account multiple serialization roots. You use this to build or read the parameters to the call you are making.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "AddNumbers", "http://calc.org/"
e.Parameters.Create "a", 10
e.Parameters.Create "b", 20
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.send "http://soap.calc.org/", e.serialize
e.parse t
wscript.echo "results = " &amp; e.parameters.item(0).Value

</SampleCode>
				</Method>
				<Method name="SerializerFactory">
					<Short><![CDATA[
This gets/sets the current SerializerFactory instance for the envelope, 
the serializer factory is used to control the COM <-> SOAP conversion process
]]></Short>
					<Links/>
					<Parameters/>
					<Description>This allows you to get/set the serializer factory for the envelope object. If you haven't set a specific serializer factory by the time its needed 
					[when serialize is called] then it will use the default one.
</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e, sf
set e = CreateObject("pocketSOAP.Envelope.2")
set sf = e.SerializerFactory
sf.ElementMapping "phone","","phoneNumber","http://contacts.org/"

</SampleCode>
				</Method>
			</Methods>
			<Description>This is the primary interface for accessing the Envelope object, it allows you access to the object model the Envelope maintains, and it allows you
to serialize and de-serialize those object models to XML/SOAP.</Description>
			<WhenToImpl>The Envelope object provides an implementation of this, you shouldn't need to implement it.</WhenToImpl>
			<WhenToCall>Use this interface to work with the Envelope object</WhenToCall>
		</Interface>
		<Interface name="ISOAPNode">
			<Short>This represents a Node [element] within the SOAP message</Short>
			<Links/>
			<Methods>
				<Method name="Name">
					<Short>The name part of the element</Short>
					<Links/>
					<Parameters/>
					<Description>This is the name of the node [localname in Xml].</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim n, e
set n = CreateObject("pocketSOAP.Node.1")
n.name = "FirstNumber"
n.value = 10

set e=CreateObject("pocketSOAP.Envelope.2")
e.SetMethod "Add", "http://calc.org/"
e.Parameters.Append n

wscript.echo e.serialize
' prints
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://calc.org/'
        xmlns:b='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:c='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:Add&gt;&lt;<b>FirstNumber b:type='c:short'&gt;10&lt;/FirstNumber&gt;</b>
&lt;/a:Add&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="Namespace">
					<Short>The namespace URI for the element name</Short>
					<Links/>
					<Parameters/>
					<Description>This is the namespace URI for the node element name</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim n, e
set n = CreateObject("pocketSOAP.Node.1")
n.name = "FirstNumber"
n.value = 10
n.URI= "http://calc.org/"

set e=CreateObject("pocketSOAP.Envelope.2")
e.SetMethod "Add", "http://calc.org/"
e.Parameters.Append n
wscript.echo e.serialize
'prints
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        <b>xmlns:a='http://calc.org/'</b>
        xmlns:b='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:c='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:Add&gt;&lt;<b>a:FirstNumber b:type='c:short'&gt;10&lt;/a:FirstNumber&gt;</b>
&lt;/a:Add&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="Type">
					<Short>The name part of the XML Type</Short>
					<Links/>
					<Parameters/>
					<Description>The is the name part of the nodes XmlType.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim n, e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "echoStruct", "http://soapinterop.org/"
set n = e.Parameters.Create ( "inputStruct", "" ) 
n.Type = "SOAPStruct"
n.TypeNS = "http://soapinterop.org/xsd"
n.Nodes.Create "varStr", "Some String"
n.Nodes.Create "varInt", 42
n.Nodes.Create "varFloat", 1.0

wscript.echo e.serialize

' this generates
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://soapinterop.org/'
        xmlns:b='http://soapinterop.org/xsd'
        xmlns:c='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:d='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:echoStruct&gt;&lt;inputStruct href='#a'/&gt;
&lt;/a:echoStruct&gt;
&lt;b:SOAPStruct E:root='0' id='a' <b>c:type='b:SOAPStruct'</b>&gt;
	&lt;varStr c:type='d:string'&gt;Some String&lt;/varStr&gt;
	&lt;varInt c:type='d:short'&gt;42&lt;/varInt&gt;
	&lt;varFloat c:type='d:double'&gt;1&lt;/varFloat&gt;
&lt;/b:SOAPStruct&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="TypeNS">
					<Short>The namespace URI for the XML Type</Short>
					<Links/>
					<Parameters/>
					<Description>This is the namespace part of the nodes XmlType.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
dim n, e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "echoStruct", "http://soapinterop.org/"
set n = e.Parameters.Create ( "inputStruct", "" ) 
n.Type = "SOAPStruct"
n.TypeNS = "http://soapinterop.org/xsd"
n.Nodes.Create "varStr", "Some String"
n.Nodes.Create "varInt", 42
n.Nodes.Create "varFloat", 1.0

wscript.echo e.serialize

' this generates
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://soapinterop.org/'
        <b>xmlns:b='http://soapinterop.org/xsd'</b>
        xmlns:c='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:d='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:echoStruct&gt;&lt;inputStruct href='#a'/&gt;
&lt;/a:echoStruct&gt;
&lt;b:SOAPStruct E:root='0' id='a' <b>c:type='b:SOAPStruct'</b>&gt;
	&lt;varStr c:type='d:string'&gt;Some String&lt;/varStr&gt;
	&lt;varInt c:type='d:short'&gt;42&lt;/varInt&gt;
	&lt;varFloat c:type='d:double'&gt;1&lt;/varFloat&gt;
&lt;/b:SOAPStruct&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="Value">
					<Short>The current value of the node</Short>
					<Links/>
					<Parameters/>
					<Description>This gets/sets the current value of the node.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
dim n, e
set n = CreateObject("pocketSOAP.Node.1")
n.name = "FirstNumber"
<b>n.value = 10</b>
n.URI= "http://calc.org/"

set e=CreateObject("pocketSOAP.Envelope.2")
e.SetMethod "Add", "http://calc.org/"
e.Parameters.Append n
wscript.echo e.serialize
'prints
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://calc.org/'
        xmlns:b='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:c='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:Add&gt;&lt;a:FirstNumber b:type='c:short'&gt;<b>10</b>&lt;/a:FirstNumber&gt;
&lt;/a:Add&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="ValueAs">
					<Short>This allows to access the current value, de-serializing it as a particular simple type if required. This is useful 
if the SOAP message doesn't contain embedded type information [via xsi:type]</Short>
					<Links/>
					<Parameters/>
					<Description>This allows to access the current value, de-serializing it as a particular simple type if required. This is useful 
if the SOAP message doesn't contain embedded type information [via xsi:type]</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
dim e , t
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "Add", "http://calc.org/"
e.Parameters.Create "a", 20
e.Parameters.Create "b", 20
set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.send "http://soap.calc.org/", e.serialize
e.parse t
wscript.echo "results = " & e.Parameters.Item(0).ValueAs ( "int", "http://www.w3.org/2001/XMLSchema" ) 
]]>
					</SampleCode>
				</Method>
				<Method name="SerializerFactory">
					<Short>Sets the instance of the serializerFactory to use if needed when ValueAs is called</Short>
					<Links/>
					<Parameters/>
					<Description>In order to call ValueAs the Node object needs access to a serializerFactory, this allows you to set the 
SerializerFactory to use. Note that during a call to ISOAPEnvelope::Parse all the created nodes are set to use the SerializerFactory 
used during parsing.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
					</SampleCode>
				</Method>
				<Method name="root">
					<Short>Indicates if this is a serialization root</Short>
					<Links/>
					<Parameters/>
					<Description>This indicates if the Node is a serialization root, typically this is managed by pocketSOAP for you.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
dim e, n
set e = CreateObject("pocketSOAP.envelope.2")
e.SetMethod = "doSomething" , "http://example.org/"
set n = e.Headers.Create ( "path", "http://soap.intermediary.org", "http://routing.soap.org/" )
n.root = true
....
]]>
					</SampleCode>
				</Method>
				<Method name="id">
					<Short>The id of the element [see multi-ref encoding in the SOAP spec]</Short>
					<Links/>
					<Parameters/>
					<Description>This donates the ID of the element, when mutli-ref encoding is being used.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="href">
					<Short>the href URI [see multi-ref encoding in the SOAP spec]</Short>
					<Links/>
					<Parameters/>
					<Description>This donates the HREF of the element, when multi-ref encoding is being used. The HREF is a URI reference that points to the 
location of the actual data for this node.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>///todo: write some sample code</SampleCode>
				</Method>
				<Method name="actor">
					<Short>The actor URI</Short>
					<Links/>
					<Parameters/>
					<Description>All SOAP Nodes do their processing in the context of a current role, typically this is the default role, and you don't need to set it. However
if you are using intermediaries, then the intermediaries act in the context of a different role. The Actor URI allows you to target a particular
header at a specific role.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>
dim e,t,n
set e = CreateObject("pocketSOAP.Envelope.2")

' call the echoString method
e.setMethod "echoString", "http://soapinterop.org/"
e.Parameters.Create "InputString" , "hello world"

' but use an intermediary to log the request/response
' the intermediary acts in the role of 'http://schemas.pocketsoap.com/logi/2001/01/'
const LOG_NS = "http://schemas.pocketsoap.com/logi/2001/01/"
set n = e.Headers.Create ("Log", "", LOG_NS)
n.actor = LOG_NS
n.root = true
n.nodes.create "NextHop", "http://soap.4s4c.com/ilab/soap.asp", LOG_NS

wscript.echo e.serialize

set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.SOAPAction="http://soapinterop.org/"
' send the request to the intermediary
t.send "http://soap.4s4c.com/log.ashx", e.serialize

e.parse t

' print the results of the echoString call
wscript.echo e.parameters.item(0).value

</SampleCode>
				</Method>
				<Method name="mustUnderstand">
					<Short>the mustUnderstand attribute, mustUnderstand is used as part of a robust versioning scheme in SOAP</Short>
					<Links/>
					<Parameters/>
					<Description>
the mustUnderstand attribute is used to indicate that a particular header must be understood by the receiver otherwise it must fault.
if mustUnderstand isn't set, then the receiver has the option to ignore any headers it doesn't know how to handle.
</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>
dim e,t,n
set e = CreateObject("pocketSOAP.Envelope.2")

' setup a header 
const LOG_NS = "http://schemas.pocketsoap.com/logi/2001/01/"
set n = e.Headers.Create ("Log", "", LOG_NS)
n.actor = LOG_NS
n.root = true
n.mustUnderstand = true
n.nodes.create "NextHop", "http://soap.4s4c.com/ilab/soap.asp", LOG_NS
...
</SampleCode>
				</Method>
				<Method name="offset">
					<Short>the array offset, used for partially transmitted arrays</Short>
					<Links/>
					<Parameters/>
					<Description>This allows access to any offset that was applied to a serialized array. Typically you don't need to use this, as the 
array deserializer will handle applying the offset for you.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>///todo: write some sample code</SampleCode>
				</Method>
				<Method name="position">
					<Short>The array item position, used by sparse arrays</Short>
					<Links/>
					<Parameters/>
					<Description>This allows access to the position of an item within an array. Typically you don't need to use this, as the array
deserializer will handle applying the position for you.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>///todo: write some sample code</SampleCode>
				</Method>
				<Method name="nil">
					<Short>This element has a nil/null value</Short>
					<Links/>
					<Parameters/>
					<Description>Indicates that the element value is nil, as defined in the XML Schema specification.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>///todo: write some sample code</SampleCode>
				</Method>
				<Method name="Nodes">
					<Short>A nodes collection object that represent the children nodes</Short>
					<Links/>
					<Parameters/>
					<Description>This returns a Nodes collection object that represents all the child nodes of this node.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>
dim e,t,n
set e = CreateObject("pocketSOAP.Envelope.2")

' call the echoString method
e.setMethod "echoString", "http://soapinterop.org/"
e.Parameters.Create "InputString" , "hello world"

' but use an intermediary to log the request/response
' the intermediary acts in the role of 'http://schemas.pocketsoap.com/logi/2001/01/'
const LOG_NS = "http://schemas.pocketsoap.com/logi/2001/01/"
set n = e.Headers.Create ("Log", "", LOG_NS)
n.actor = LOG_NS
n.root = true
' create a new node as a child of the header node.
n.nodes.create "NextHop", "http://soap.4s4c.com/ilab/soap.asp", LOG_NS
....
</SampleCode>
				</Method>
			</Methods>
			<Description>This interface is the primary access to the Node object.</Description>
			<WhenToImpl>You shouldn't need to implement this interface</WhenToImpl>
			<WhenToCall>Call this interface to manipulate Node objects</WhenToCall>
		</Interface>
		<Interface name="ISOAPNodes">
			<Short>This is the main interface to the Nodes collection object</Short>
			<Links/>
			<Methods>
				<Method name="_NewEnum">
					<Short>A standard COM enumerator, allows use of the "for each node in nodes" functionality</Short>
					<Links/>
					<Parameters/>
					<Description>This is a standard COM enumerator, which provides an enumerator of the current collection of nodes.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>
dim e, t
set e = CreateObject("pocketSOAP.Envelope.2")
set t = CreateObject("pocketSOAP.HTTPTransport.2")
...
e.parse t

' using the 'for each item in collection' syntax in VB maps to a call to _NewEnum
for each n in e.Parameters
	wscript.echo n.Name &amp; " : " &amp; n.Value
next

</SampleCode>
				</Method>
				<Method name="Item">
					<Short>Access a specific child item, by offset</Short>
					<Links/>
					<Parameters/>
					<Description>Accesses a child Node from the collection, given its ordinal position.</Description>
					<ReturnValue>The requested Node object, or if the request ordinal is outside the valid range, the E_INVALIDARG error is returned.</ReturnValue>
					<SampleCode>
dim e, t
set e = CreateObject("pocketSOAP.Envelope.2")
set t = CreateObject("pocketSOAP.HTTPTransport.2")
...
e.parse t

for i = 0 to e.Parameters.Count
	wscript.echo e.Parameters.Item(i).Name &amp; " : " &amp; e.Parameters.Item(i).Value
next

</SampleCode>
				</Method>
				<Method name="ItemByName">
					<Short>Access a specific child item, by name and namespace URI</Short>
					<Links/>
					<Parameters/>
					<Description>This returns the first node in the collection with a matching Name &amp; Namespace URI.</Description>
					<ReturnValue>The first node with a matching Name &amp; Namespace URI, or if one is not found the E_INVALIDARG error is returned.</ReturnValue>
					<SampleCode>
dim e,t,n
set e = CreateObject("pocketSOAP.Envelope.2")
set t = CreateObject("pocketSOAP.HTTPTransport.2")
' call the echoString method
e.setMethod "echoString", "http://soapinterop.org/"
e.Parameters.Create "InputString" , "hello world"
' but use an intermediary to log the request/response
' the intermediary acts in the role of 'http://schemas.pocketsoap.com/logi/2001/01/'
const LOG_NS = "http://schemas.pocketsoap.com/logi/2001/01/"
set n = e.Headers.Create ("Log", "", LOG_NS)
n.actor = LOG_NS
n.root = true
' create a new node as a child of the header node.
n.nodes.create "NextHop", "http://soap.4s4c.com/ilab/soap.asp", LOG_NS
t.send "http://soap.4s4c.com/log.ashx", e.serialize
e.parse t

wscript.echo e.Headers.ItemByName("LogInfo", LOG_NS).Value

</SampleCode>
				</Method>
				<Method name="Count">
					<Short>The number of nodes in the collection</Short>
					<Links/>
					<Parameters/>
					<Description>returns the number of nodes currently in the collection</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.Parameters.Create "a", 10
e.Parameters.Create "b", 20
' prints 2
wscript.echo e.Parameters.Count 
</SampleCode>
				</Method>
				<Method name="Append">
					<Short>Adds a new node to the end of the collection</Short>
					<Links/>
					<Parameters>
						<Parameter name="newNode">The node to add</Parameter>
					</Parameters>
					<Description>This allows to append an already constructed Node object into the collection.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e, n
set e = CreateObject("pocketSOAP.Envelope.2")
e.SetMethod "Add", "http://calc.org/"
set n = CreateObject("pocketSOAP.Node.1")
n.name = "a"
n.value = 10
e.Parameters.Append n
</SampleCode>
				</Method>
				<Method name="Clear">
					<Short>removes all items from the collection</Short>
					<Links/>
					<Parameters/>
					<Description>Removes all the nodes from the collection</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.Parameters.Create "aa", 10
' prints 1
wscript.echo e.Parameters.Count 
e.Paramters.Clear
' prints 0
wscript.echo e.Parameters.Count 
</SampleCode>
				</Method>
				<Method name="Create">
					<Short>Creates and initializes a new node, add it to the collection and returns it. </Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">Set the name of the new node to this</Parameter>
						<Parameter name="Val">Set the node value to this</Parameter>
						<Parameter name="Namespace">Set the namespace URI of the name to this</Parameter>
						<Parameter name="Type">Set the name of the XmlType to this</Parameter>
						<Parameter name="TypeNamespace">Set the namespace URI of the XmlType to this</Parameter>
						<Parameter name="newNode">returns a pointer to the new node.</Parameter>
					</Parameters>
					<Description>This allows you to create and initialize a new node, and add it to the collection, all the one go. This
makes it easy to build up parameter and other nodes.</Description>
					<ReturnValue>returns a pointer to the newly created node object.</ReturnValue>
					<SampleCode>
						<![CDATA[
dim e , n
set e = CreateObject("pocketSOAP.Envelope.2")
e.SetMethod "echoStruct", "http://soapinterop.org/"
set n = e.Parameters.Create ( "inputStruct", "", "", "SOAPStruct", "http://soapinterop.org/xsd")
n.Nodes.Create "varString", "string"
n.Nodes.Create "varFloat", 123.456
n.Nodes.Create "varInt", 42
wscript.echo e.serialize
' prints
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://soapinterop.org/'
        xmlns:b='http://soapinterop.org/xsd'
        xmlns:c='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:d='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:echoStruct&gt;&lt;inputStruct href='#a'/&gt;
&lt;/a:echoStruct&gt;
&lt;b:SOAPStruct E:root='0' id='a' c:type='b:SOAPStruct'&gt;&lt;varString c:type='d:string'&gt;string&lt;/varString&gt;
&lt;varFloat c:type='d:double'&gt;123.456&lt;/varFloat&gt;
&lt;varInt c:type='d:short'&gt;42&lt;/varInt&gt;
&lt;/b:SOAPStruct&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;

]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This is the primary interface for working with collections of nodes</Description>
			<WhenToImpl>There is a standard implementation of this [see the CNodes class], you shouldn't need to implement this.</WhenToImpl>
			<WhenToCall>Call this interface to manipulate a collection of nodes.</WhenToCall>
		</Interface>
		<Interface name="ISerializerOutput">
			<Short>This represents the current serialization stream, to properly handle mutli-ref encoding, the serializer engine will
switch the actual stream this points to between the main stream, and the independent elements stream as required.</Short>
			<Links/>
			<Methods>
				<Method name="StartElement">
					<Short>This starts a new element in the current serialization stream.</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The element name</Parameter>
						<Parameter name="Namespace">the namespace URI for the element, the serializer engine will automatically map a prefix to this URI for you</Parameter>
					</Parameters>
					<Description>
Creates a new element in the stream. Typically this is not used, you would normally use <b>SerializeNode</b> or <b>SerializeValue</b>
to generate any child nodes, as these functions will automatically apply the multi-ref encoding rules for you.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    <b>dest.StartElement "Key", NS</b>
    Dim a As AuthInfo
    Set a = Val
    dest.WriteText a.authKey
    dest.EndElement "Key", NS
    <b>dest.StartElement "Type", NS</b>
    dest.WriteText a.authType
    dest.EndElement "Type", NS
End Sub


When called this would add &lt;x:Key&gt;AuthKeyValueHere&lt;/x:Key&gt;&lt;x:Type&gt;AuthTypeValueHere&lt;/x:Type&gt; to the serialization stream, 
in addition a namespace declaration xmlns:x='http://auth.example.org/2001/01/' would be added so that the x prefix is in scope.
]]>
					</SampleCode>
				</Method>
				<Method name="EndElement">
					<Short>Creates a closing Element in the stream</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The element name</Parameter>
						<Parameter name="Namespace">the namespace URI for the element, the serializer engine will automatically map a prefix to this URI for you</Parameter>
					</Parameters>
					<Description>Creates a closing element in the stream. Typically this is not used, you would normally use <b>SerializeNode</b> or <b>SerializeValue</b>
to generate any child nodes, as these functions will automatically apply the multi-ref encoding rules for you.</Description>
					<ReturnValue>
					</ReturnValue>
					<SampleCode><![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    dest.StartElement "Key", NS
    Dim a As AuthInfo
    Set a = Val
    dest.WriteText a.authKey
    <b>dest.EndElement "Key", NS</b>
    dest.StartElement "Type", NS
    dest.WriteText a.authType
    <b>dest.EndElement "Type", NS</b>
End Sub


When called this would add &lt;x:Key&gt;AuthKeyValueHere&lt;/x:Key&gt;&lt;x:Type&gt;AuthTypeValueHere&lt;/x:Type&gt; to the serialization stream, 
in addition a namespace declaration xmlns:x='http://auth.example.org/2001/01/' would be added so that the x prefix is in scope.
]]>
					</SampleCode>
				</Method>
				<Method name="Attribute">
					<Short>Writes a attribute value to the stream</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The attribute name</Parameter>
						<Parameter name="Namespace">The namespace for the attribute name, the serializer engine will automatically map a prefix to this URI for you</Parameter>
						<Parameter name="value">The attribute value</Parameter>
					</Parameters>
					<Description>Writes an attribute and value to the stream. A prefix will be generated for the namespace as required.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim a As AuthInfo
    Set a = Val

    dest.Attribute "Type", NS, a.authType
    dest.WriteText a.authKey
End Sub

This inserts x:Type='authType'&gt;AuthKey into the stream, note that the serialization engine adds the containing element info, so the total results xml would be
&lt;h:Auth x:Type='authType'&gt;AuthKey&lt;/h:Auth&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="QNameAttribute">
					<Short>Write a attribute value to the stream, whose value is a QName [Qualified Name]</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The attribute name</Parameter>
						<Parameter name="Namespace">The namespace for the attribute name, the serializer engine will automatically map a prefix to this URI for you</Parameter>
						<Parameter name="value">The name of the value</Parameter>
						<Parameter name="valueNamespace">The namespace for the value, the serializer engine will automatically map a prefix to this URI for you</Parameter>
					</Parameters>
					<Description>This writes a attribute to the stream, who's value is a QName, prefix's will be automatically generated for both the attribute name
and the attribute value</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim a As AuthInfo
    Set a = Val

    dest.QNameAttribute "Type", NS, a.authType, NS
    dest.WriteText a.authKey
End Sub

This inserts x:Type='x:authType'&gt;AuthKey into the stream, note that the serialization engine adds the containing element info, so the total results xml would be
&lt;h:Auth x:Type='x:authType'&gt;AuthKey&lt;/h:Auth&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="SerializeNode">
					<Short>Takes the Node and serializes it, multi-ref encoding rules are applied as needed</Short>
					<Links/>
					<Parameters>
						<Parameter name="n">The node to serialize</Parameter>
					</Parameters>
					<Description>This takes a SOAPNode object and serializes it, mutli-ref encoding rules are applied as needed.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim a As AuthInfo
    Set a = Val
	' authInfo has two properties, which are actually SOAPNode objects.
	dest.SerializeNode a.Type
	dest.SerializeNode a.Key
End Sub
]]>
					</SampleCode>
				</Method>
				<Method name="SerializeValue">
					<Short>Takes the value and serializes it, multi-ref encoding rules are applied as needed</Short>
					<Links/>
					<Parameters>
						<Parameter name="v">The value to serialize</Parameter>
						<Parameter name="Name">The name for the value</Parameter>
						<Parameter name="NameNS">The namespace for the value name</Parameter>
					</Parameters>
					<Description>This takes a Variant value and serializes it within the specified name [and namespace]. multi-ref encoding rules are applied as needed.
The serializerFactory is used to find the appropriate serializer object.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim a As AuthInfo
    Set a = Val
	' authInfo has two properties, which are strings
	dest.SerializeValue a.Type, "type", NS
	dest.SerializeValue a.Key,  "type", NS
End Sub
]]>
					</SampleCode>
				</Method>
				<Method name="WriteText">
					<Short>Writes out textual data as an element value, XML escaping is applied as needed.</Short>
					<Links/>
					<Parameters>
						<Parameter name="text">The text to serialize</Parameter>
					</Parameters>
					<Description>This writes out text as an element value. It is assumed that the source text is not XML aware, and so has XML encoding rules applied to it.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim a As AuthInfo
    Set a = Val
    dest.WriteText a.Username
End Sub

if a.Username returns "Simon&amp;Simon", then Simon&amp;amp;Simon will be written to the stream.
]]>
					</SampleCode>
				</Method>
				<Method name="WriteTextNoEncoding">
					<Short>Write out textual data as an element value, No XML escaping is applied, it is up to you to ensure this is well formed XML</Short>
					<Links/>
					<Parameters>
						<Parameter name="text">The text to serialize</Parameter>
					</Parameters>
					<Description>Write out textual data as an element value, No XML escaping is applied, it is up to you to ensure this is well formed XML. When
you know the text is XML safe, then you can use this method instead of WriteText as it doesn't carry the overhead of checking and encoding
the string.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim a As AuthInfo
    Set a = Val
    dest.WriteTextNoEncoding a.Username
End Sub

' in this example, we know that a.Username will never contain any characters that need encoding. 
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>
This interface allows serializer objects to call back into the serializer engine to work together in generating the XML/SOAP representation.
</Description>
			<WhenToImpl>There's a standard implementation of this provided, you shouldn't need to implement it.</WhenToImpl>
			<WhenToCall>Call this interface when you are writing serializer objects.</WhenToCall>
		</Interface>
		<Interface name="ISerializerContext">
			<Short>This interface allows you access to various pieces of contextual information you may want access to whilst doing serialization</Short>
			<Links/>
			<Methods>
				<Method name="Namespaces">
					<Short>This returns an interface to the Namespace manager, typically you don't need to use this, as all the serialize functions with URIs handle the prefix mappings for you.</Short>
					<Links/>
					<Parameters/>
					<Description>This returns an interface to the Namespace manager, typically you don't need to use this, as all the serialize functions with URIs handle the prefix mappings for you.</Description>
					<ReturnValue>This returns an interface to the namespace manager associated with the current serialization.</ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    dim ns as ISOAPNamespaces
    set ns = ctx.Namespaces
	dim prefix as string
	prefix = ns.GetPrefixForURI(NS)
	...    
End Sub
]]>
					</SampleCode>
				</Method>
				<Method name="SerializerFactory">
					<Short>This allows access to the current serializer factory.</Short>
					<Links/>
					<Parameters/>
					<Description>This allows access to the current serializer factory. Typically you don't need this, rather you should just call <b>SerializeNode</b> or <b>SerializeValue</b>, 
which will look for the correct serializer in the serializerFactory. 
One time you do need access to this is to find out what the current namespace URI is for XSI [the XML Schema Instance namespace]</Description>
					<ReturnValue>An interface to the current serializerFactory</ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Implements ISoapSerializer

Private Const NS = "http://auth.example.org/2001/01/"

Private Sub ISoapSerializer_Serialize(  Val As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    dim sf as ISerializerFactory    
    set sf = ctx.SerializerFactory
    ' add an xsi:type='x:auth' attribute
    ' make sure the xsi prefix is ascociated with the correct XSI namespace for the primaryNS.
    dest.QNameAttribute "type", sf.XsiForPrimaryNS, "auth", NS
End Sub
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface allows you access to various pieces of context information you may need during the serialization process.</Description>
			<WhenToImpl>The serializer engine provides a standard implementation of this, you shouldn't need to implement it.</WhenToImpl>
			<WhenToCall>Call this interface to access context information when the functions in ISerializerOutput don't provide what you need.</WhenToCall>
		</Interface>
		<Interface name="ITypesInit">
			<Short>This optional interface indicates to the serializerFactory that you are interested in receiving the type information it used to select the [de]serializer.</Short>
			<Links/>
			<Methods>
				<Method name="Initialize">
					<Short>Once the serializerFactory has created the serializer, it calls this passing the type information it used to select this [de]serializer</Short>
					<Links/>
					<Parameters>
						<Parameter name="xmlType">The name of the XmlType</Parameter>
						<Parameter name="xmlTypeNamespace">The namespace of the XmlType</Parameter>
						<Parameter name="comType">The COM type, the exact meaning of the COM type for deserialization is dependent upon the deserializer, typically it is either
an integer value represent the VARTYPE [for simple types], or it is a stringified IID [for objects]</Parameter>
					</Parameters>
					<Description>
Once the serializerFactory has created the serializer, it calls this passing the type information it used to select this [de]serializer. The [de]serializer
can later use this information as needed, e.g. to write out an xsi:type='ns:type' attribute during serialization.
</Description>
					<ReturnValue>
Raise an error here if either the Xml Type or COM type is unexpected. This will stop the serialization process, and bubble the error to the calling code.
</ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Private Const NS = "http://auth.example.org/2001/01/"

Implements ISoapSerializer
Implements ITypesInit

Private m_type As String
Private m_ns As String

Private Sub ITypesInit_Initialize(ByVal XmlType As String, ByVal XmlTypeNamespace As String, ByVal ComType As Variant)
    m_type = XmlType
    m_ns = XmlTypeNamespace
End Sub

Private Sub ISoapSerializer_Serialize(V As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
    Dim sf As CoSerializerFactory
    Set sf = ctx.SerializerFactory
    dest.QNameAttribute "type", sf.XsiForPrimaryNS, m_type, m_ns
    dest.SerializeValue V.Key, "key", NS
    dest.SerializeValue V.Type, "type", NS
End Sub
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This optional interface indicates to the serializerFactory that you are interested in receiving the type information it used to select the [de]serializer. 
This can be useful if you have a single [de]serializer object that handles many XML and/or COM types.</Description>
			<WhenToImpl>Implement this if you are writing a serializer or deserializer and want to find out the information the serializerFactory used to select this [de]serializer.</WhenToImpl>
			<WhenToCall>The serializerFactory object will call this interface as required.</WhenToCall>
		</Interface>
		<Interface name="ISoapSerializer">
			<Short>The serializer engine requires that all serializer objects implement this interface</Short>
			<Links/>
			<Methods>
				<Method name="Serialize">
					<Short>The serializer engine will call this method when it requires a value serializing</Short>
					<Links/>
					<Parameters>
						<Parameter name="val">The value to serialize</Parameter>
						<Parameter name="ctx">An interface pointer to the current serialization context</Parameter>
						<Parameter name="dest">The serialization destination, the serializer should make calls against this interface to generate the serialized representation</Parameter>
					</Parameters>
					<Description>Once the serializer engine has created a particular serializer it will call the serialize method to have it convert the COM value into
					a SOAP/XML representation.<br/>
					At this point serializer engine has already creating the start of the element, along with its correct name &amp; namespace prefix. 
					If you need to add any attributes to the element call ISerializerOutput::Attribute or ISerializerOutput::QNameAttribute.
					When the Serialize method returns, the serializer engine will automatically add the closing element.
					</Description>
					<ReturnValue>
					If the serializer returns an error from this method, then the serialization is stopped, and the error is propagated to the caller.
					</ReturnValue>
					<SampleCode>
						<![CDATA[
Visual Basic Class File

Private Const NS = "http://auth.example.org/2001/01/"

Implements ISoapSerializer
Implements ITypesInit

Private m_type As String
Private m_ns As String

Private Sub ITypesInit_Initialize(ByVal XmlType As String, ByVal XmlTypeNamespace As String, ByVal ComType As Variant)
    m_type = XmlType
    m_ns = XmlTypeNamespace
End Sub

Private Sub ISoapSerializer_Serialize(V As Variant, _
                                      ByVal ctx As PocketSOAP.ISerializerContext, _
                                      ByVal dest As PocketSOAP.ISerializerOutput)
    Dim sf As CoSerializerFactory
    Set sf = ctx.SerializerFactory
    
    ' write out the xsi:type='xsd:foo' attribute
    dest.QNameAttribute "type", sf.XsiForPrimaryNS, m_type, m_ns
    
    ' write out a child element {http://auth.example.org/2001/01/}key with the value V.Key
    dest.SerializeValue V.Key, "key", NS
    
    ' write out a child element {http://auth.example.org/2001/01/}type with the value v.Type
    dest.SerializeValue V.Type, "type", NS
End Sub
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This is the standard interface for serializer objects.</Description>
			<WhenToImpl>Implement this interface when you are writing your own serializer objects.</WhenToImpl>
			<WhenToCall>Typically this interface is only called by the serializer engine.</WhenToCall>
		</Interface>
		<Interface name="ISoapDeSerializerAttributes">
			<Short>This allows access to the attributes on the element currently being deserialized</Short>
			<Links/>
			<Methods>
				<Method name="Exists">
					<Short>Does a particular attribute exist</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The name of the attribute</Parameter>
						<Parameter name="Namespace">The namespace URI of the attribute</Parameter>
						<Parameter name="Exists">returns VARIANT_TRUE if it exists, otherwise returns VARIANT_FALSE</Parameter>
					</Parameters>
					<Description>This allows you to check to see if a particular attribute exists in the element being de-serialized.</Description>
					<ReturnValue>returns VARIANT_TRUE if there is an attribute with a matching name and namespace URI, otherwise returns VARIANT_FALSE</ReturnValue>
					<SampleCode>
						<![CDATA[
Option Explicit

Implements ISoapDeSerializer

Private Sub ISoapDeSerializer_Start(ByVal node As PocketSOAP.ISOAPNode, ByVal ElementName As String, ByVal Attributes As PocketSOAP.ISoapDeSerializerAttributes, ByVal ns As PocketSOAP.ISOAPNamespaces)
    If Not Attributes.Exists("arrayType", "http://schemas.xmlsoap.org/soap/encoding/") Then
        Err.Raise vbObjectError + 9876, , "Array is missing arrayType attribute!"
    End If
End Sub
]]>
					</SampleCode>
				</Method>
				<Method name="Value">
					<Short>returns a particular attributes value</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The name of the attribute</Parameter>
						<Parameter name="Namespace">The namespace URI of the attribute</Parameter>
						<Parameter name="val">The value</Parameter>
					</Parameters>
					<Description>This returns the value of a particular attribute [as identified by its name and namespace URI]</Description>
					<ReturnValue>The attribute value [as a string], or if the attribute does not exist on this element the error E_INVALIDARG is returned.</ReturnValue>
					<SampleCode>
						<![CDATA[
Option Explicit

const SOAP_ENC = "http://schemas.xmlsoap.org/soap/encoding/"

Implements ISoapDeSerializer

Private Sub ISoapDeSerializer_Start(ByVal node As PocketSOAP.ISOAPNode, ByVal ElementName As String, ByVal Attributes As PocketSOAP.ISoapDeSerializerAttributes, ByVal ns As PocketSOAP.ISOAPNamespaces)
    If Not Attributes.Exists("arrayType", SOAP_ENC ) Then
        Err.Raise vbObjectError + 9876, , "Array is missing arrayType attribute!"
    End If
    dim arrType as string
    arrType = Attributes.Value("arrayType", SOAP_ENC )
    CrackSoapArrayType arrType
    ...
End Sub
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface allows access to any attributes for the current element during de-serialization.</Description>
			<WhenToImpl>The de-serialization engine provides a standard implementation of this, you shouldn't need to implement it.</WhenToImpl>
			<WhenToCall>Call this during de-serialization if you need to find out information about attributes.
			</WhenToCall>
		</Interface>
		<Interface name="ISoapDeSerializer">
			<Short>Deserializer objects are required to implement this</Short>
			<Links/>
			<Methods>
				<Method name="Start">
					<Short>The deserializer engine calls this to start a new deserialization process</Short>
					<Links/>
					<Parameters>
						<Parameter name="node">The resulting node that needs updating with the finalized value</Parameter>
						<Parameter name="ElementName">The name of the element being de-serialized</Parameter>
						<Parameter name="Attributes">Access to any attributes that may be on this element</Parameter>
						<Parameter name="ns">Allows access to the namespace manager, so that you can do prefix/URI mappings</Parameter>
					</Parameters>
					<Description>The de-serializer engine calls this to start de-serializing the current element into a COM value.</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode>
						<![CDATA[
Option Explicit

const SOAP_ENC = "http://schemas.xmlsoap.org/soap/encoding/"

Implements ISoapDeSerializer

Private Sub ISoapDeSerializer_Start(ByVal node As PocketSOAP.ISOAPNode, ByVal ElementName As String, ByVal Attributes As PocketSOAP.ISoapDeSerializerAttributes, ByVal ns As PocketSOAP.ISOAPNamespaces)
    If Not Attributes.Exists("arrayType", SOAP_ENC ) Then
        Err.Raise vbObjectError + 9876, , "Array is missing arrayType attribute!"
    End If
    dim arrType as string
    arrType = Attributes.Value("arrayType", SOAP_ENC )
    CrackSoapArrayType arrType
    ...
End Sub
]]>
					</SampleCode>
				</Method>
				<Method name="Child">
					<Short>The deserializer engine will call this when it finds a child element</Short>
					<Links/>
					<Parameters>
						<Parameter name="id">an integer that represent the internal id of this node</Parameter>
						<Parameter name="ready">if VARIANT_TRUE, the child has been fully de-serialized and you can the Value[As] on the child. if VARIANT_FALSE
then the child is still not fully de-serialized [due to id/href lookups], you shouldn't call Value[As] on the child yet, as it isn't right.
The deserializer engine will later make a call to ChildReady, once the child is fully deserialized.</Parameter>
						<Parameter name="childNode">the child node object</Parameter>
					</Parameters>
					<Description>If the deserialization engine finds a child element, then the child element will be deserialized and the resulting
					node object passed through a call to Child. If the Child is fully de-serialized  then the ready parameter will be VARIANT_TRUE,
					otherwise [due to it having a href reference to a multi-ref
					value we have yet de-serialized] the ready parameter will be VARIANT_FALSE. 
					<br/><br/>
					In the case that ready is VARIANT_FALSE, calling get_Value()
					on the childNode object has undefined results. You shouldn't call get_Value() on the child until the child is ready, as indicated
					by a subsequent call to ChildReady with a matching id value.
					</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ChildReady">
					<Short>The deserializer engine will call this to inform you that a child node has finished de-serialization, and you can complete any 
actions you need to take with that node.</Short>
					<Links/>
					<Parameters>
						<Parameter name="id">an integer that represent the internal id of this node</Parameter>
						<Parameter name="childNode">the child node object</Parameter>
					</Parameters>
					<Description>The deserializer engine will call this to inform you that a child node has finished de-serialization, and you can complete any 
actions you need to take with that node. This will only be called for child nodes that you were initially notified as not being ready [i.e. ready was VARIANT_FALSE
in the call to Child]</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ChildRef">
					<Short>The deserializer engine will call this when you have a child that contains a href attribute.</Short>
					<Links/>
					<Parameters>
						<Parameter name="href">the value of the href attribute</Parameter>
						<Parameter name="hrefNode">the node object that contains the href attribute</Parameter>
					</Parameters>
					<Description>
					The deserializer engine will call this when you have a child that contains a href attribute [ChildRef is called instead of Child].
					At some point later, the deserializer engine will call Ref with an id that matches the href, this node contains the actual value.
					</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Ref">
					<Short>The deserializer engine will call this when it finds the matching id of a previous ChildRef node.</Short>
					<Links/>
					<Parameters>
						<Parameter name="id">the id declared on this node [not the same as the internal id used in child/childready]</Parameter>
						<Parameter name="idNode">The node object [typically this node has the value you are interested in]</Parameter>
					</Parameters>
					<Description>
					If the deserialization engine finds a reference to a multi-reference value, then it initially calls the ChildRef method, once
					it finds the actual mutli-reference value, it will then call Ref passing in the node that represent the value. If the multi-ref
					value has already been de-serialized, then the call to Ref will immediately follow the call to ChildRef.
					</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Characters">
					<Short>The deserializer engine will call this when it finds character data for you to de-serialize.</Short>
					<Links/>
					<Parameters>
						<Parameter name="charData">The accumulated character data.</Parameter>
					</Parameters>
					<Description>If there is text data within an element, the de-serializer engine will accumulate the total text, and then call
					Characters. Typically this is the string value of simple types.</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="End">
					<Short>Deserialization of this node is complete, the deserialize should update the node with the finalized value at this point, and release its Node pointer.</Short>
					<Links/>
					<Parameters/>
					<Description>
					Once the deserialization engine has determined that this particular value is finished [i.e. all the children have been fully processed]
					it will call End. The de-serializer should update the node object with the finalized value at this point, and then release its Node pointer.
					</Description>
					<ReturnValue>Throw an error to stop the de-serialization process, the error will be returned to the client.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This is the standard interface that all de-serializers should implement. The deserialization engine will make calls to this interface
			during the de-serialization process.</Description>
			<WhenToImpl>Implement this interface if you are writing your own deserialization object.</WhenToImpl>
			<WhenToCall>Typically the deserialization engine calls this interface as needed, you should need to call it.</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactory">
			<Short>This is the interface to the serializerFactory that the serializer engine uses, the serializer factory is used
to find the correct serializer for particular types, its where most of the "knowledge" about XSD is coded.</Short>
			<Links/>
			<Methods>
				<Method name="SerializerForValue">
					<Short>Given a variant value, find a suitable serializer for it</Short>
					<Links/>
					<Parameters>
						<Parameter name="v">The value to find a serializer for</Parameter>
						<Parameter name="s">The matching serializer, if the serializer also implements ITypesInit, then the serializer factory will of already called ITypesInit::Initialize(...)</Parameter>
					</Parameters>
					<Description>Finds a serializer object for the given COM value. The resulting serializer should be passed to ReturnSerializer when finished with, so that it is returned to the pool, and re-used if required.</Description>
					<ReturnValue>Either a serializer object that matches the requested Value, or E_NO_SERIALIZER</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="SerializerForNode">
					<Short>Given a CoSOAPNode object, find a suitable serializer for the nodes value [this is a shortcut for ISoapNode::get_Value(); SerializerForValue()]</Short>
					<Links/>
					<Parameters>
						<Parameter name="n">The node to find a serializer for</Parameter>
						<Parameter name="s">The matching serializer, if the serializer also implements ITypesInit, then the serializer factory will of already called ITypesInit::Initialize(...)</Parameter>
					</Parameters>
					<Description>Given a CoSOAPNode object, find a suitable serializer for the nodes value [this is a shortcut for ISoapNode::get_Value(); SerializerForValue()</Description>
					<ReturnValue>Either a serializer object that matches the requested Value, or E_NO_SERIALIZER</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ReturnSerializer">
					<Short>Once the serializer engine has finished with a serializer, it calls returnSerializer, so that the serializer can be returned to the pool.</Short>
					<Links/>
					<Parameters>
						<Parameter name="s">The serializer</Parameter>
					</Parameters>
					<Description>Once the serializer is finished with it should be returned to the pool by calling ReturnSerializer. Serializers are pooled during the duration of the Serialize method for performance reasons.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="DeserializerForType">
					<Short>Given an Xml type, find a suitable deserializer</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlType">The Xml Type name</Parameter>
						<Parameter name="XmlTypeNamespace">The namespace URI for the Xml Type [this is typically the XSD namespace URI]</Parameter>
						<Parameter name="IsArray">If set to VARIANT_FALSE, then this will find a deserializer suitable for a single instance of the Xml type, otherwise it returns a deserializer suitable for handling an array of that type.</Parameter>
						<Parameter name="s">The matching serializer, if the serializer also implements ITypesInit, then the serializer factory will of already called ITypesInit::Initialize(...)</Parameter>
					</Parameters>
					<Description>For a specific Xml Type (identified by its NamespaceURI/Localname pair), find a suitable de-serializer.</Description>
					<ReturnValue>A suitable de-serializer for that type, or E_NO_DESERIALIZER if there is no suitable match</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="DeserializerForElement">
					<Short>Given an element QName, find a suitable de-serializer.</Short>
					<Links/>
					<Parameters>
						<Parameter name="elementName">the element name</Parameter>
						<Parameter name="elementNamespace">the namespace of the element</Parameter>
						<Parameter name="IsArray">If set to VARIANT_FALSE, then this will find a deserializer suitable for a single instance of the element, otherwise it returns a deserializer suitable for handling an array..</Parameter>
						<Parameter name="s">The matching serializer, if the serializer also implements ITypesInit, then the serializer factory will of already called ITypesInit::Initialize(...)</Parameter>
					</Parameters>
					<Description>For a particular element (identified by its NamespaceURI/Localname pair) find a suitable de-serializer. 
					This uses the element name to type mappings setup via calls to ElementMapping</Description>
					<ReturnValue>A suitable de-serializer for that element, or E_NO_DESERIALIZER if there is no suitable match</ReturnValue>
					<SampleCode>///todo: write some sample code</SampleCode>
				</Method>
				<Method name="ReturnDeSerializer">
					<Short>Returns the de-serializer object, back to the pool</Short>
					<Links/>
					<Parameters>
						<Parameter name="s">The deserializer</Parameter>
					</Parameters>
					<Description>Once the de-serializer is finished with it should be returned to the de-serializer pool.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="XsiForPrimaryNS">
					<Short>Returns the XML Schema Instance namespaceURI for the current primary Schema Namespace</Short>
					<Links/>
					<Parameters>
						<Parameter name="uri">The XSI namespace that matches the primary XSD namespace</Parameter>
					</Parameters>
					<Description>The serializer factory keeps track of the current primary XSD namespace, which allows the serializer engine to serialize using the older XSD namespace. 
This allows a serializer to find out what the matching XSI [XML Schema Instance] namespace is for the current primary XSD Namespace (e.g. to generate xsi:type attributes)</Description>
					<ReturnValue>A string containing the NamespaceURI of the XML Schema Instance for the current primary Schema Namespace</ReturnValue>
					<SampleCode>
						<![CDATA[
HRESULT CSerializerSimpleBase::WriteType(VARIANT * val, ISerializerContext * ctx, ISerializerOutput * dest ) 
{
	if ( m_type.Length() ) 
	{
		CComPtr<ISerializerFactory> sf ;
		ctx->get_SerializerFactory(&sf) ;
		CComBSTR xsi ;
		sf->XsiForPrimaryNS(&xsi) ;
		static CComBSTR type (OLESTR("type")) ;
		dest->QNameAttribute ( type, xsi, m_type, m_typeNS ) ;
	}
	return S_OK ;
}
]]>
					</SampleCode>
				</Method>
				<Method name="IsAnyType">
					<Short>Given an Xml Type, it will return true if it is an AnyType type [xsd:anyType for the 2001 XSD Schema or xsd:ur-type for the 1999 XSD schema]</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlType">The Xml Type name</Parameter>
						<Parameter name="XmlTypeNamespace">The namespace URI of the Xml Type name</Parameter>
						<Parameter name="IsAnyType">returns VARIANT_TRUE if the type is one of the AnyType types</Parameter>
					</Parameters>
					<Description>Given an Xml Type, it will return true if it is an AnyType type [xsd:anyType for the 2001 XSD Schema or xsd:ur-type for the 1999 XSD schema]</Description>
					<ReturnValue>VARIANT_TRUE or VARIANT_FALSE</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="AreEqualComTypes">
					<Short>Given a pair of Xml Types, this method calculates if a de-serialized instance of both types would result in the same COM type</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlTypeA">Xml Type Name A</Parameter>
						<Parameter name="XmlTypeNSA">Xml Type namespace A</Parameter>
						<Parameter name="XmlTypeB">Xml Type Name B</Parameter>
						<Parameter name="XmlTypeNSB">Xml Type namespace B</Parameter>
						<Parameter name="Match">the result</Parameter>
					</Parameters>
					<Description>Given a pair of Xml Types, this method calculates if a de-serialized instance of both types would result in the same COM type</Description>
					<ReturnValue>VARIANT_TRUE or VARIANT_FALSE</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="FindComType">
					<Short>Given a particular Xml Type, this returns the resulting COM if an instance of that type was deserialized</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlType">The Xml Type name</Parameter>
						<Parameter name="XmlTypeNamespace">The Xml Type namespace</Parameter>
						<Parameter name="comType">The resulting COM Type</Parameter>
					</Parameters>
					<Description>Given a particular Xml Type, this returns the resulting COM if an instance of that type was deserialized</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface is primaryly used internally by the PocketSOAP serialization and deserialization engine
			to map between XML and COM types</Description>
			<WhenToImpl>Implement this if you want to completely customize the Type mapping process.</WhenToImpl>
			<WhenToCall>Call this interface to access type mapping information during serialization or deserialization</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryConfig">
			<Short>This interface is used to configure an instance of the serializerFactory</Short>
			<Links/>
			<Methods>
				<Method name="ElementMapping">
					<Short>Create a mapping between an element QName and a Xml Type</Short>
					<Links/>
					<Parameters>
						<Parameter name="ElementName">The Element name</Parameter>
						<Parameter name="ElementNamespace">The Element namespace</Parameter>
						<Parameter name="Type">The Xml Type for this element</Parameter>
						<Parameter name="TypeNamespace">The Xml Type namespace for this element</Parameter>
					</Parameters>
					<Description>This allows you to associate XML Types with elements found during parsing with no inline type attribute. This is useful when working with
servers that don't include type information in their responses. </Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode><![CDATA[
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "echoFloat", "http://soapinterop.org/"
e.Parameters.Create "inputFloat", 42.42
' when parsing the response treat a &lt;return&gt; element as a XSD:float
e.SerializerFactory.ElementMapping "return", "", "http://www.w3.org/1999/XMLSchema", "float"
...
]]>
					</SampleCode>
				</Method>
				<Method name="Deserializer">
					<Short>This registers a new deserializer</Short>
					<Links/>
					<Parameters>
						<Parameter name="Type">The Xml Type name that this deserializer can deserialize</Parameter>
						<Parameter name="TypeNamespace">The Xml Type namespace that this deserializer can deserialize</Parameter>
						<Parameter name="ArrayOf">Does this deserialize a single instance of the type, or an array of the type ?</Parameter>
						<Parameter name="ComType">The resulting COM type following a successful deserialization</Parameter>
						<Parameter name="ProgID">The ProgID of the deserializer to register</Parameter>
					</Parameters>
					<Description>This registers a new de-serializer for a particular XML type [or array of]. The de-serializer is responsible for converting the XML Stream into a 
concrete COM type. You can register a deserializer for an existing [custom or standard] XML type, and it will replace the existing de-serializer, for example
this allows you to replace the standard array deserializer with one that deserializes arrays into a COM collection object, rather than a SAFEARRAY.
</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>
dim e
set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "echoFloat", "http://soapinterop.org/"
e.Parameters.Create "inputFloat", 42.42
' when parsing, deserialize a {urn:xml-soap-address-demo}phone element with the property bag deserializer
e.SerializerFactory.Deserializer "phone", "urn:xml-soap-address-demo", false, "AddressBook.Phone", "pocketSOAP.SerializerPB.1"
...

</SampleCode>
				</Method>
				<Method name="Serializer">
					<Short>This registers a new serializer</Short>
					<Links/>
					<Parameters>
						<Parameter name="ComType">The COM type that this serializer will serialize</Parameter>
						<Parameter name="Type">The resulting Xml Type after serialization</Parameter>
						<Parameter name="TypeNamespace">The namespace of the Xml Type</Parameter>
						<Parameter name="ProgID">The ProgID of the serializer</Parameter>
					</Parameters>
					<Description>This registers a new serializer for a particular COM type. The serializer [in conjunction with the serializer engine] is responsible for converting the COM type into
its SOAP/XML representation. You can register a new serializer for an existing COM type, so that you can override any of the standard serializers if you need to.</Description>
					<ReturnValue>///todo: discuss the possible return values</ReturnValue>
					<SampleCode>
dim e, a, af
set af = CreateObject("AddressBook.Locator")
set a = af.GetAddressFor("Simon Fell")

set e = CreateObject("pocketSOAP.Envelope.2")
e.setMethod "updateAddress", "urn:xml-soap-address-demo"

e.Parameters.Create "address", a
' to specify a serializer for a COM object, you enter an interface IID for the object as the COM Type
' use the AddressBook.AddressSerializer to serialize any objects that implement the {407ECB10-29A0-43cd-A89E-8EBFD662211F} interface
e.SerializerFactory.Serializer "{407ECB10-29A0-43cd-A89E-8EBFD662211F}", "address","urn:xml-soap-address-demo", "AddressBook.AddressSerializer"
...
</SampleCode>
				</Method>
				<Method name="PrimarySchema">
					<Short>get/sets the primary schema that the serializer factory will try and generate serializations in. This defaults to the XSD recommendation version.</Short>
					<Links/>
					<Parameters/>
					<Description>
get/sets the primary schema that the serializer factory will try and generate serializations in. This defaults to the XSD recommendation version.
[http://www.w3.org/2001/XMLSchema]. Some older SOAP servers only support the earlier 1999 schema version [as that was the draft at the time the
SOAP spec was written], to switch to using the 1999 schema instead, set this property to http://www.w3.org/1999/XMLSchema
</Description>
					<ReturnValue>The current Namespace URI associated with the active schema version, this defaults to http://www.w3.org/2001/XMLSchema</ReturnValue>
					<SampleCode><![CDATA[
dim e
set e = CreateObject("pocketSOAP.Envelope.2")

' we are talking to an old endpoint, and have to use the old 1999 schema version
e.SerializerFactory.PrimarySchema = "http://www.w3.org/1999/XMLSchema"

e.setMethod "echoInt", "http://soapinterop.org/"
e.Parameters.create "inputInt", 42
wscript.echo e.serialize

' this generates the following SOAP message
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://soapinterop.org/'
        xmlns:b='http://www.w3.org/1999/XMLSchema-instance'
        xmlns:c='http://www.w3.org/1999/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:echoInt&gt;&lt;inputInt b:type='c:short'&gt;42&lt;/inputInt&gt;
&lt;/a:echoInt&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;

]]>
					</SampleCode>
				</Method>
				<Method name="RootFirst">
					<Short>This controls whether independent serialization roots are serialized before or after the main serialization root.</Short>
					<Links/>
					<Parameters/>
					<Description>
When serializing to XML, the serializer engine will place all values that could be multi-references as independent elements [this save's it from
having to traverse the values to serialize twice]. The SOAP spec doesn't dictate the order between the real serialization root and the independent 
roots. The RootsFirst property allows you to specify if you want the main serialization root first, or the independent elements first. Many servers
incorrectly assume that the first child of the Body element is the main serialization root [this is wrong, they should look at the root attribute],
and for that reason it defaults to true [i.e. the main serialization root is first]. However if you are dealing with a streaming based parser, it
is more efficient to have as many independent roots de-serialized first [as the deserializer doesn't have to go back and fixup things its partially 
de-serialized].
</Description>
					<ReturnValue>a VARIANT_BOOL containing the current RootsFirst property value</ReturnValue>
					<SampleCode><![CDATA[
dim e, n
set e = CreateObject("pocketSOAP.Envelope.2")
e.SetMethod "echoStruct", "http://soapinterop.org/"
set n = e.Parameters.Create ("inputStruct", "","", "SOAPStruct", "http://soapinterop.org/xsd")
n.Nodes.Create "varInt", 42
n.Nodes.Create "varFloat", 42.42
n.Nodes.Create "varString", "Zaphod"

' first off, the default, the serialization root is first
wscript.echo "RootFirst" & vbCRLF & e.serialize

e.SerializerFactory.RootFirst = false
wscript.echo vbCRLF & "RootLast" & vbCRLF & e.serialize


' this generates
RootFirst
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://soapinterop.org/'
        xmlns:b='http://soapinterop.org/xsd'
        xmlns:c='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:d='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;a:echoStruct&gt;&lt;inputStruct href='#a'/&gt;
&lt;/a:echoStruct&gt;
&lt;b:SOAPStruct E:root='0' id='a' c:type='b:SOAPStruct'&gt;&lt;varInt c:type='d:short'&gt;42&lt;/varInt&gt;
&lt;varFloat c:type='d:double'&gt;42.42&lt;/varFloat&gt;
&lt;varString c:type='d:string'&gt;Zaphod&lt;/varString&gt;
&lt;/b:SOAPStruct&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;

RootLast
&lt;S:Envelope
        S:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
        xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        xmlns:a='http://soapinterop.org/'
        xmlns:b='http://soapinterop.org/xsd'
        xmlns:c='http://www.w3.org/2001/XMLSchema-instance'
        xmlns:d='http://www.w3.org/2001/XMLSchema'&gt;
&lt;S:Body&gt;&lt;b:SOAPStruct E:root='0' id='a' c:type='b:SOAPStruct'&gt;&lt;varInt c:type='d:short'&gt;42&lt;/varInt&gt;
&lt;varFloat c:type='d:double'&gt;42.42&lt;/varFloat&gt;
&lt;varString c:type='d:string'&gt;Zaphod&lt;/varString&gt;
&lt;/b:SOAPStruct&gt;
&lt;a:echoStruct&gt;&lt;inputStruct href='#a'/&gt;
&lt;/a:echoStruct&gt;
&lt;/S:Body&gt;&lt;/S:Envelope&gt;
]]>
					</SampleCode>
				</Method>
				<Method name="SetConfig">
					<Short>Set the serializer factory to a known configuration</Short>
					<Links/>
					<Parameters>
						<Parameter name="config">the configuration to select, currently only sfcNormal (0) and sfcScripting (1) are supported</Parameter>
					</Parameters>
					<Description>This selects a preset serializerFactory configuration. Currently the two supported configurations are sfcNormal and sfcScripting. In 
Scripting mode all arrays are de-serialized into arrays of variants, rather than the more strong typed arrays that you get in normal mode.<br/>
A future version will allow you to load a serializerFactory configuration from an external configuration file.</Description>
					<ReturnValue>Returns E_INVALIDARG if the config parameter is not SfcNormal [0] or sfcScripting [1]</ReturnValue>
					<SampleCode><![CDATA[
dim e, t
set e = CreateObject("pocketSOAP.Envelope.2")
e.SerializerFactory.SetConfig 1
e.setMethod "echoStringArray", "http://soapinterop.org/"
e.Parameters.Create "inputStringArray", array("one", "two", "three")

set t = CreateObject("pocketSOAP.HTTPTransport.2")
t.send "http://soap.4s4c.com/ilab/soap.asp", e.serialize
e.parse t
wscript.echo "response type = " & typename(e.parameters.item(0).value)

' even though the 4s4c server returns the array as arrayType="xsd:string[3]", this prints
response type = Variant()
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface is used to configure the serializerFactory</Description>
			<WhenToImpl>There is a standard implementation of this interface you should only implement it if you are replacing the standard serializer factory</WhenToImpl>
			<WhenToCall>Call this to alter the serializerFactory configuration from the defaults.</WhenToCall>
		</Interface>
		<Interface name="ISwATransport">
			<Short>Transport objects implement this interface to indicate that they can support payloads with Attachments (either DIME or SwA)</Short>
			<Links/>
			<Methods>
				<Method name="ContentType">
					<Short>This gets/sets the ContentType for the request.</Short>
					<Links/>
					<Parameters/>
					<Description>This is typically text/xml; charset=UTF-8 by default, however for transporting SwA messages
		it should be changed to mutlipart/related, and for DIME it should be application/dime. (Note that the Attachments manager will do this for you)</Description>
					<ReturnValue>The current value of the request content type header</ReturnValue>
					<SampleCode><![CDATA[
		dim t as object, swat as ISwATransport
		set t = CreateObject("pocketSOAP.HTTPTransport.2")
		set swat = t
		swat.ContentType = "mutlipart/related; boundary=""MimeBoundary_42""; start=""<first.part@eaxmple.org>"" type=text/xml"
		t.Send "http://swa.4s4c.com/swa.asp", BuildSWAPayload()
		...
		]]>
					</SampleCode>
				</Method>
				<Method name="Send">
					<Short>Sends the payload to the specified endpoint.</Short>
					<Links/>
					<Parameters>
						<Parameter name="endpoint">The endpoint URL to send the payload to (e.g. http://soap.4s4c.com/ssss4c/soap.asp)</Parameter>
						<Parameter name="Payload">The payload to send, this can be either a string (VT_BSTR), and array of bytes (VT_ARRAY | VT_UI1) or a data stream ( An implementation of IStreamReader )</Parameter>
					</Parameters>
					<Description>Sends the payload to the specified endpoint. The payload can be represented as a string, array or as a stream, allowing large payloads to be sent, without them 
				having to be entirely in memory.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Receive">
					<Short>Retreives the response to a previous Send.</Short>
					<Links/>
					<Parameters>
						<Parameter name="characterEncoding">The character encoding that the response SOAP message should be treated as (if the transport wants to override it)</Parameter>
						<Parameter name="responseStream">A IStreamReader implementation that respresents the response data.</Parameter>
					</Parameters>
					<Description>This retreives the response to a previous call to Send, and exposes the resposne as a data stream.(an IStreamReader). This
				allows for large response messages to be handled without it having to be buffered entirely in memory first.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface signals that the particular transport can handle SwA or DIME payloads.</Description>
			<WhenToImpl>Implement this interface when you are writing a new transport object, that will support attachments via DIME or SwA payloads.</WhenToImpl>
			<WhenToCall>Call this interface to set the transport object up to send messages that include attachments.</WhenToCall>
		</Interface>
		<Interface name="ISOAPNode2">
			<Short>This extends the ISOAPNode interface to include EncodingStyle support.</Short>
			<Links/>
			<Methods>
				<Method name="EncodingStyle">
					<Short>The EncodingStyle URI for this node.</Short>
					<Links/>
					<Parameters/>
					<Description>This is the EncodingStyle URI for this node. If the Node is created via CoCreateInstance [or new in VB] then the
		EncodingStyle default to the standard SOAP section 5 encodingStyle of <b>http://schemas.xmlsoap.org/soap/encoding/</b>. If
		the node is created via the Create method on the Nodes collection object, then it inherits the encodingStyle of its parent node
		(at creation time). Setting the encodingStyle to anything other than <b>http://schemas.xmlsoap.org/soap/encoding/</b> will 
		disable the section 5 encoding support during serialization, making it easier to generate SOAP messages based on schemas without
		having to write a custom serializer.
		</Description>
					<ReturnValue>The current value of the EncodingStyle URI property.</ReturnValue>
					<SampleCode><![CDATA[
		dim e, n
		set e = CreateObject("pocketSOAP.Envelope.2")
		e.SetMethod "doFoo", "http://www.foo.org/"
		e.EncodingStyle = ""
		set n = e.Parameters.Create("one", empty)
		n.Nodes.Create "two", "some string"
		wscript.echo e.serialize

		' generates this, note how the sub nodes inherit their encoding Style
		' from the envelope.
		&lt;S:Envelope
	        S:encodingStyle=''
    	    xmlns:E='http://schemas.xmlsoap.org/soap/encoding/'
        	xmlns:S='http://schemas.xmlsoap.org/soap/envelope/'
	        xmlns:a='http://www.foo.org/'
    	    xmlns:c='http://www.w3.org/2001/XMLSchema'
        	xmlns:b='http://www.w3.org/2001/XMLSchema-instance'&gt;
		&lt;S:Body&gt;&lt;a:doFoo&gt;&lt;one&gt;&lt;two b:type='c:string'&gt;some string&lt;/two&gt;
		&lt;/one&gt;
		&lt;/a:doFoo&gt;
		&lt;/S:Body&gt;&lt;/S:Envelope&gt;
		]]>
					</SampleCode>
				</Method></Methods>
			<Description>This extends the ISOAPNode interface to include EncodingStyle support.</Description>
			<WhenToImpl>The CoSoapNode object provides a standard implementation of this interface.</WhenToImpl>
			<WhenToCall>Call this interface to work with the SOAPNode object</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryPool">
			<Short>This allows access to the serializer pool maintained by the serializerFactory</Short>
			<Links/><Methods><Method name="Reset">
					<Short>Removes all entries from the current serializer pool.</Short>
					<Links/>
					<Parameters/><Description>Removes all entries from the serializer pool.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
		CComPtr&lt;ISerializerFactory&gt; sf ;
		GetSerializerFactory(&sf) ;
		CComPtr&lt;ISerializerFactoryPool&gt; sfp ;
		sf->QueryInterface(&sfp) ;
		sfp->Reset() ;
		]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This allows access to the serializer pool maintained by the serializerFactory</Description>
			<WhenToImpl>The serializer factory provides a standard implementation of this.</WhenToImpl>
			<WhenToCall>Call this interface if you need to manually empty the serializer pool.</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryConfig2">
			<Short>This allows you to setup local element type mappings.
		</Short>
			<Links/>
			<Methods>
				<Method name="LocalTypeMapping">
					<Short>Registers a new local type mapping.</Short>
					<Links/>
					<Parameters>
						<Parameter name="ParentXmlType">The XmlType of the containing element type</Parameter>
						<Parameter name="ParentXmlTypeNS">The namespace of the containing element type</Parameter>
						<Parameter name="ChildName">The element name to register a type for</Parameter>
						<Parameter name="ChildNamespace">The namespace of the element name to register a type for</Parameter>
						<Parameter name="Type">The XmlType of the element</Parameter>
						<Parameter name="TypeNamespace">The namespace of the XmlType of the element</Parameter>
					</Parameters>
					<Description>Registers a new local element type mapping. This is the mapping from an element name to an Xml Type, however it is scoped 
by the containing type. This allows you to have multiple elements with the same name, but for them to have different types
depending upon the type of the element they are contained within.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
set e = CreateObject("pocketSOAP.Envelope.2")
const XSD = "http://www.w3.org/2001/XMLSchema"
e.SerializerFactory.LocalTypeMapping "one",  "http://soapinterop.org/", "item", "", "string", XSD
e.SerializerFactory.LocalTypeMapping "two",  "http://soapinterop.org/", "item", "", "int",    XSD
e.SerializerFactory.LocalTypeMapping "three","http://soapinterop.org/", "item", "", "float",  XSD

e.parse GetTestMsg

for i = 0 to e.parameters.count-1
	set n = e.parameters.item(i).Nodes.item(0)
	wscript.echo n.Name & " -&gt; " & n.Value & " -&gt; " & TypeName(n.Value)
next

Function GetTestMsg()
	m = "&lt;S:Envelope xmlns:SOAP-ENV='http://schemas.xmlsoap.org/soap/envelope/' " + _
		 "SOAP-ENV:encodingStyle='http://schemas.xmlsoap.org/soap/encoding/' xmlns:E='http://schemas.xmlsoap.org/soap/encoding/' " + _
		 "xmlns:S='http://schemas.xmlsoap.org/soap/envelope/' " + _
		 "xmlns:d='http://soapinterop.org/' " + _
		 "xmlns:xs='http://www.w3.org/2001/XMLSchema' " + _
		 "xmlns:xi='http://www.w3.org/2001/XMLSchema-instance'&gt;" + _
		 "&lt;S:Body&gt;&lt;d:testFooResponse&gt;" + _
		 "&lt;a xi:type='d:one'&gt;&lt;item&gt;String&lt;/item&gt;&lt;/a&gt;" + _
		 "&lt;b xi:type='d:two'&gt;&lt;item&gt;1414&lt;/item&gt;&lt;/b&gt;" + _
		 "&lt;c xi:type='d:three'&gt;&lt;item&gt;33.33&lt;/item&gt;&lt;/c&gt;" + _ 
		 "&lt;/d:testFooResponse&gt;&lt;/S:Body&gt;&lt;/S:Envelope&gt;"
	GetTestMsg = m
end Function

' generates
item -&gt; Text -&gt; String
item -&gt; 1414 -&gt; Long
item -&gt; 33.33 -&gt; Single
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface extends the ISerializerFactoryConfig interface to add support for configuring local type mappings.</Description>
			<WhenToImpl>The serializerFactory provides a standard implementation of this.</WhenToImpl>
			<WhenToCall>Call this interface to register local type mappings with the serializerFactory</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactory2">
			<Short>Extends the type resolution to include local types support.</Short>
			<Links/>
			<Methods>
				<Method name="DeserializerForChild">
					<Short>Finds a de-serializer for a particular child element</Short>
					<Links/>
					<Parameters>
						<Parameter name="ParentType">The Type of the containing element</Parameter>
						<Parameter name="ParentTypeNS">The TypeNamespace of the containing element</Parameter>
						<Parameter name="elementName">The childName to look for</Parameter>
						<Parameter name="elementNamespace">The childName namespace to look for</Parameter>
						<Parameter name="IsArray">Is this an array of items, or a single item ?</Parameter>
						<Parameter name="XmlType">If a match is found, this is the resulting XmlType registered</Parameter>
						<Parameter name="XmlTypeNS">If a match is found, this is the namespace of the resulting XmlType registered</Parameter>
						<Parameter name="s">An instance of a de-serializer suitable for this type.</Parameter>
					</Parameters>
					<Description>Find a suitable de-serializer for a given element, that is contained within a given type. Pass empty strings for ParentType and ParentTypeNS
to indicate that there is no parentType [this is then equivalent to calling DeserializerForElement]. Local type mappings are checked first,
if no suitable mapping is found there, then the global type mappings [as set via calls to ElementMapping] are checked.</Description>
					<ReturnValue>returns S_OK if a suitable de-serializer was found, or E_NO_DESERIALIZER</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This extends the serializerFactory to include local type support.</Description>
			<WhenToImpl>The serializerFactory contains a standard implementation of this.</WhenToImpl>
			<WhenToCall>The Envelope Parser will call this as required, its unlikely that you need to call it yourself.</WhenToCall>
		</Interface>
		<Interface name="ISOAPTransportTimeout">
			<Short>Indicates that the transport supports Timeouts, and allows you to alter the timeout value.</Short>
			<Links/>
			<Methods>
				<Method name="Timeout">
					<Short>This get/sets the current timeout value [in milliseconds].</Short>
					<Links/>
					<Parameters/>
					<Description>This get/sets the current timeout value [in milliseconds]. The same value is used for both the send and receive timeout.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
set t = CreateObject("pocketSOAP.HTTPTRansport.2")
t.SOAPAction = "http://soapinterop.org/"
t.Timeout = 30000
t.Send "http://soap.4s4c.com/ilab/soap.asp", test1Envelope
....
</SampleCode>
				</Method>
			</Methods>
			<Description>This interface indicates that a particular transport supports user settable timeouts.</Description>
			<WhenToImpl>Implement this interface if you are writing a SOAP transport that includes user settable timeouts.</WhenToImpl>
			<WhenToCall>Call this to alter the default timeout on transports that support timeouts.</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryPool2">
			<Short>This interface is used to access the [de]serializer pool</Short>
			<Links/>
			<Methods>
				<Method name="Fetch">
					<Short>get an instance of the specified [de]serializer, creating a new one if needed.</Short>
					<Links/>
					<Parameters>
						<Parameter name="clsid">the CLSID of the required [de]serializer.</Parameter>
						<Parameter name="ppUnk">The resulting [de]serializer object.</Parameter>
					</Parameters>
					<Description>get an instance of the specified [de]serializer, creating a new one if needed.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface is used to access the [de]serializer pool</Description>
			<WhenToImpl>Implement this, if you're providing a new pooling mechanism</WhenToImpl>
			<WhenToCall>The SerializerFactory calls this interface when it needs serializer instances.</WhenToCall>
		</Interface>
		<Interface name="IXmlQName">
			<Short>An XML QName</Short>
			<Links/>
			<Methods>
				<Method name="Name">
					<Short>The (local)Name of the QName</Short>
					<Links/>
					<Parameters/>
					<Description>This is the localname part of the QName</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Namespace">
					<Short>The namespace URI part of the QName</Short>
					<Links/>
					<Parameters/>
					<Description>The namespace URI part of the QName</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Set">
					<Short>Initializes the QName with the name/namespace</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The new (local)name part</Parameter>
						<Parameter name="Namespace">The new namespace URI part</Parameter>
					</Parameters>
					<Description>Initializes the QName with this name/namespace pair.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>An interface for accessing XML QName information (name &amp; namespace)</Description>
			<WhenToImpl>Implement this if you are providing something that is an XML QName</WhenToImpl>
			<WhenToCall>Call this interface to read/write the XMLQName properties</WhenToCall>
		</Interface>
		<Interface name="ISOAPNode3">
			<Short>Extends the ISOAPNode so that you can tell if the root attribute was explicitly set in the message.</Short>
			<Links/>
			<Methods>
				<Method name="explicitRoot">
					<Short>Was the root attriubte present during de-serialization</Short>
					<Links/>
					<Parameters/>
					<Description>Was the root attriubte present during de-serialization</Description>
					<ReturnValue>VARIANT_TRUE or VARIANT_FALSE</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>Extends the ISOAPNode so that you can tell if the root attribute was explicitly set in the message.</Description>
			<WhenToImpl>There's a standard implementation of this</WhenToImpl>
			<WhenToCall>Call this if you need to determine if the root attribute was present or not during de-serialization</WhenToCall>
		</Interface>
		<Interface name="IInterfaceFinder">
			<Short>Extracts Interface type information at runtime</Short>
			<Links/>
			<Methods>
				<Method name="DefaultIID">
					<Short>Find the InterfaceID of the default interface.</Short>
					<Links/>
					<Parameters>
						<Parameter name="theClass">The CLSID or ProgID of the object to check</Parameter>
						<Parameter name="iid">The stringified Interface ID of the default interface of the requested object</Parameter>
					</Parameters>
					<Description>Finds the InterfaceID of the default interface for a particular object.</Description>
					<ReturnValue>A stringified interfaceID e.g. {B37A49AA-5E39-46DE-8821-0457B8E04915}</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>Extracts Interface type information at runtime</Description>
			<WhenToImpl>There's a standard implementation of this interface</WhenToImpl>
			<WhenToCall>Call this to deffer gathering type information til runtime, useful for VB based projects, that use custom serializers.</WhenToCall>
		</Interface>
		<Interface name="ISimpleSoapSerializer">
			<Short>An interface for serializing XML Schema simple tyeps.</Short>
			<Links/>
			<Methods>
				<Method name="Serialize">
					<Short>Serializes the value to an XML simple type string.</Short>
					<Links/>
					<Parameters>
						<Parameter name="val">The value to serialize</Parameter>
						<Parameter name="ctx">The current serialization context, use this to access prefix mappings etc.</Parameter>
						<Parameter name="dest">The resulting serialized string</Parameter>
					</Parameters>
					<Description>Serializes a COM type to a XML simple type. The serialized value is returned as a string.</Description>
					<ReturnValue>A string representing the serialized type</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>Custom serializers that serialize XML Schema simple types should implement this interface.</Description>
			<WhenToImpl>Implement this if you are writing a customised serializer for XML Schema simple types.</WhenToImpl>
			<WhenToCall>The serializer engine will call this as needed.</WhenToCall>
		</Interface>
		<Interface name="ISimpleSoapDeSerializer">
			<Short>Deserializes simple types into COM values</Short>
			<Links/>
			<Methods>
				<Method name="Deserialize">
					<Short>Deserialize a XML Schema simple type into a COM Type</Short>
					<Links/>
					<Parameters>
						<Parameter name="characters">The simple type to deserialize</Parameter>
						<Parameter name="ns">The currently in scope namespaces</Parameter>
						<Parameter name="dest">The resulting COM value</Parameter>
					</Parameters>
					<Description>Deserializes a XML Schema simple type into a COM value.</Description>
					<ReturnValue>A variant containing the resulting deserialized value</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface is used to deserialize XML Schema simple types into COM values.</Description>
			<WhenToImpl>Implement this if you are writing custom Simple Type deserializers.</WhenToImpl>
			<WhenToCall>The deserialization engine will call this as needed.</WhenToCall>
		</Interface>
		<Interface name="ISerializerOutput2">
			<Short>Allows you to serialize any COM value via a registered Simple Type serializer as an attribute value.</Short>
			<Links/>
			<Methods>
				<Method name="SerializeAttribute">
					<Short>Serialize the given COM value as an XML attribute.</Short>
					<Links/>
					<Parameters>
						<Parameter name="value">The value of the attribute</Parameter>
						<Parameter name="Name">The localname of the attribute</Parameter>
						<Parameter name="Namespace">The namespace of the attribute</Parameter>
					</Parameters>
					<Description>Serializes the COM value as an XML attribute. The serializer engine will use the serializerFactory to find
		a simepleType serializer for the specified COM type.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode>
						<![CDATA[
Private Sub ISoapSerializer_Serialize(  theVal As Variant, _
                                        ByVal ctx As PocketSOAP.ISerializerContext, _
                                        ByVal dest As PocketSOAP.ISerializerOutput)
        Dim val As Person
        Set val = theVal
        Dim d2 As ISerializerOutput2
        Set d2 = dest
        d2.SerializeAttribute val.name, "Name", ""
        d2.SerializeAttribute val.Male, "Male", ""
        dest.SerializeValue val.Age, "Age", "http://soapinterop.org/xsd"
        dest.SerializeValue val.id, "ID", "http://soapinterop.org/xsd"
End Sub

]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface allows you to serialize attribute values, automatically finding the correct serializer for the type.</Description>
			<WhenToImpl>the EnvWriter class provides a standard implementation of this.</WhenToImpl>
			<WhenToCall>call this from custom serializers to generated attrbiutes.</WhenToCall>
		</Interface>
		<Interface name="ISoapDeSerializerAttributes2">
			<Short>Allows you to access typed attributes values, getting the de-serialized as required.</Short>
			<Links/>
			<Methods>
				<Method name="ValueAs">
					<Short>Extract the typed attribute value, getting it de-serialized to a COM value along the way.</Short>
					<Links/>
					<Parameters>
						<Parameter name="Name">The name of the attribute to deserialize</Parameter>
						<Parameter name="Namespace">The namespace of the attribute to deserialize</Parameter>
						<Parameter name="XmlType">The Xml Type of the attribute value</Parameter>
						<Parameter name="TypeNamespace">The Xml Type namespace of the attribute value</Parameter>
						<Parameter name="value">The resulting de-serialized value</Parameter>
					</Parameters>
					<Description>Extract the typed attribute value, getting it de-serialized to a COM value along the way.</Description>
					<ReturnValue>the resulting de-serialized attrbiute value</ReturnValue>
					<SampleCode>
						<![CDATA[
Private Sub ISoapDeSerializer_Start(	ByVal node As PocketSOAP.ISOAPNode, _
                                        ByVal ElementName As String, _
                                        ByVal Attributes As PocketSOAP.ISoapDeSerializerAttributes, _
                                        ByVal ns As PocketSOAP.ISOAPNamespaces)
        Set m_obj = CreateObject(m_comtype)
        node.Value = m_obj
        Dim a As ISoapDeSerializerAttributes2
        Set a = Attributes
        m_obj.name = a.ValueAs("Name", "", "string", "http://www.w3.org/2001/XMLSchema")
        m_obj.Male = a.ValueAs("Male", "", "boolean", "http://www.w3.org/2001/XMLSchema")
End Sub
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>Provides access to typed attribute values</Description>
			<WhenToImpl>There is a standard implemention of this</WhenToImpl>
			<WhenToCall>Call this when writing custom de-serializers that need to de-serialize typed attribute values.</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryEx">
			<Short>Extended serializerFactory methods</Short>
			<Links/>
			<Methods>
				<Method name="SerializerForValue">
					<Short>Find a serializer for a particular value, taking into account, its serialization context.</Short>
					<Links/>
					<Parameters><Parameter name="v">The value to serialize</Parameter>
						<Parameter name="ParentType">The containing XML Type.</Parameter>
						<Parameter name="ParentTypeNS">The namespace of the containing XML Type</Parameter>
						<Parameter name="name">The name of this value</Parameter>
						<Parameter name="Namespace">The namespace for this value</Parameter>
						<Parameter name="type">This receives the matching XML typename</Parameter>
						<Parameter name="typeNamespace">The receives the namespace of the matching XML type.</Parameter>
						<Parameter name="s">The matching serializer to use.</Parameter>
					</Parameters>
					<Description>Finds a serializer for a particular value, taking into account its serialization context, such as containg type and element name.
		This allows values with the same COM type, to have different resulting XML types, depending on their context. e.g. a particular
		service may want to get one parameter as a xsd:base64Binary, and another parameter as an xsd:hexBinary, both of these are represented as
		bytes arrays in COM, so this allows to handle those context specific mappings.</Description>
					<ReturnValue>The type, typeNamespace and resulting Serializer will be populated following the call.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="SerializerForNode">
					<Short>Find a serializer for a particular Nodes value, taking into account, its serialization context.</Short>
					<Links/>
					<Parameters><Parameter name="n">The node whose value needs a serializer</Parameter>
						<Parameter name="ParentType">The containing XML Type.</Parameter>
						<Parameter name="ParentTypeNS">The namespace of the containing XML Type</Parameter>
						<Parameter name="name">The name of this value</Parameter>
						<Parameter name="Namespace">The namespace for this value</Parameter>
						<Parameter name="type">This receives the matching XML typename</Parameter>
						<Parameter name="typeNamespace">The receives the namespace of the matching XML type.</Parameter>
						<Parameter name="s">The matching serializer to use.</Parameter>
					</Parameters>
					<Description>Finds a serializer for a particular Node value, taking into account its serialization context, such as containg type and element name.
		This allows values with the same COM type, to have different resulting XML types, depending on their context. e.g. a particular
		service may want to get one parameter as a xsd:base64Binary, and another parameter as an xsd:hexBinary, both of these are represented as
		bytes arrays in COM, so this allows to handle those context specific mappings.</Description>
					<ReturnValue>The type, typeNamespace and resulting Serializer will be populated following the call.</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ReturnSerializer">
					<Short>returns a serializer to the pool</Short>
					<Links/>
					<Parameters>
						<Parameter name="s">The serializer previously obtained by a call to SerializerForNode/SerializerForValue</Parameter>
					</Parameters>
					<Description>Returns a serializer instance back to the pool</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode></Method>
				<Method name="DeserializerForType">
					<Short>Given an Xml type, find a suitable deserializer</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlType">The Xml Type name</Parameter>
						<Parameter name="XmlTypeNamespace">The namespace URI for the Xml Type [this is typically the XSD namespace URI]</Parameter>
						<Parameter name="IsArray">If set to VARIANT_FALSE, then this will find a deserializer suitable for a single instance of the Xml type, otherwise it returns a deserializer suitable for handling an array of that type.</Parameter>
						<Parameter name="s">The matching serializer, if the serializer also implements ITypesInit, then the serializer factory will of already called ITypesInit::Initialize(...)</Parameter>
					</Parameters>
					<Description>For a specific Xml Type (identified by its NamespaceURI/Localname pair), find a suitable de-serializer.</Description>
					<ReturnValue>A suitable de-serializer for that type, or E_NO_DESERIALIZER if there is no suitable match</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="DeserializerForElement">
					<Short>Given an element QName and its context, find a suitable de-serializer.</Short><Links/><Parameters>
						<Parameter name="ParentType">The containing XML Type</Parameter>
						<Parameter name="ParentTypeNS">The namespace of the containing XML Type</Parameter>
						<Parameter name="elementName">The Element name</Parameter>
						<Parameter name="elementNamespace">The namespace of the element</Parameter>
						<Parameter name="IsArray">Is this a SOAP encoded array ?</Parameter>
						<Parameter name="XmlType">The resulting XML type</Parameter>
						<Parameter name="XmlTypeNS">The resulting namespace of the XML type</Parameter>
						<Parameter name="s">A suitable de-serializer</Parameter></Parameters>
					<Description>Finds the XML Type and a de-serializer for that type, from an element name &amp; containing type.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ReturnDeSerializer">
					<Short>Returns the de-serializer object, back to the pool</Short>
					<Links/>
					<Parameters>
						<Parameter name="s">The deserializer</Parameter>
					</Parameters>
					<Description>Once the de-serializer is finished with it should be returned to the de-serializer pool.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="FindType">
					<Short>Given an element name and containing type, look for its registered XML type.</Short>
					<Links/>
					<Parameters>
						<Parameter name="ParentType">The containing XML Type</Parameter>
						<Parameter name="ParentTypeNS">The namespace of the containing XML type</Parameter>
						<Parameter name="elementName">The element name</Parameter>
						<Parameter name="elementNamespace">The namespace of the element</Parameter>
						<Parameter name="XmlType">The resulting XML typename</Parameter>
						<Parameter name="XmlTypeNS">The namespace of the resulting XML typename</Parameter>
					</Parameters>
					<Description>Given an element name and its containg type, look for a register local type mapping that tells us the elements XML Type</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="XsiForPrimaryNS">
					<Short>Returns the XML Schema Instance namespaceURI for the current primary Schema Namespace</Short>
					<Links/>
					<Parameters>
						<Parameter name="uri">The XSI namespace that matches the primary XSD namespace</Parameter>
					</Parameters>
					<Description>The serializer factory keeps track of the current primary XSD namespace, which allows the serializer engine to serialize using the older XSD namespace. 
This allows a serializer to find out what the matching XSI [XML Schema Instance] namespace is for the current primary XSD Namespace (e.g. to generate xsi:type attributes)</Description>
					<ReturnValue>A string containing the NamespaceURI of the XML Schema Instance for the current primary Schema Namespace</ReturnValue>
					<SampleCode>
						<![CDATA[
HRESULT CSerializerSimpleBase::WriteType(VARIANT * val, ISerializerContext * ctx, ISerializerOutput * dest ) 
{
	if ( m_type.Length() ) 
	{
		CComPtr<ISerializerFactory> sf ;
		ctx->get_SerializerFactory(&sf) ;
		CComBSTR xsi ;
		sf->XsiForPrimaryNS(&xsi) ;
		static CComBSTR type (OLESTR("type")) ;
		dest->QNameAttribute ( type, xsi, m_type, m_typeNS ) ;
	}
	return S_OK ;
}
]]>
					</SampleCode>
				</Method>
				<Method name="IsAnyType">
					<Short>Given an Xml Type, it will return true if it is an AnyType type [xsd:anyType for the 2001 XSD Schema or xsd:ur-type for the 1999 XSD schema]</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlType">The Xml Type name</Parameter>
						<Parameter name="XmlTypeNamespace">The namespace URI of the Xml Type name</Parameter>
						<Parameter name="IsAnyType">returns VARIANT_TRUE if the type is one of the AnyType types</Parameter>
					</Parameters>
					<Description>Given an Xml Type, it will return true if it is an AnyType type [xsd:anyType for the 2001 XSD Schema or xsd:ur-type for the 1999 XSD schema]</Description>
					<ReturnValue>VARIANT_TRUE or VARIANT_FALSE</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="AreEqualComTypes">
					<Short>Given a pair of Xml Types, this method calculates if a de-serialized instance of both types would result in the same COM type</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlTypeA">Xml Type Name A</Parameter>
						<Parameter name="XmlTypeNSA">Xml Type namespace A</Parameter>
						<Parameter name="XmlTypeB">Xml Type Name B</Parameter>
						<Parameter name="XmlTypeNSB">Xml Type namespace B</Parameter>
						<Parameter name="Match">the result</Parameter>
					</Parameters>
					<Description>Given a pair of Xml Types, this method calculates if a de-serialized instance of both types would result in the same COM type</Description>
					<ReturnValue>VARIANT_TRUE or VARIANT_FALSE</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="FindComType">
					<Short>Given a particular Xml Type, this returns the resulting COM if an instance of that type was deserialized</Short>
					<Links/>
					<Parameters>
						<Parameter name="XmlType">The Xml Type name</Parameter>
						<Parameter name="XmlTypeNamespace">The Xml Type namespace</Parameter>
						<Parameter name="comType">The resulting COM Type</Parameter>
					</Parameters>
					<Description>Given a particular Xml Type, this returns the resulting COM if an instance of that type was deserialized</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This is the new interface for the serializerFactory, it's a version of ISerializerFactory that includes support for local type mappings</Description>
			<WhenToImpl>There's a standard implementation of this provided</WhenToImpl>
			<WhenToCall>The serializer and deserializer engines will call this as needed, you shouldn't need to call it yourself.</WhenToCall>
		</Interface>
		<Interface name="IStreamReader">
			<Short>A simple stream reader interface, that supports resetable streams</Short>
			<Links/>
			<Methods>
				<Method name="Read">
					<Short>read data from the stream</Short>
					<Links/>
					<Parameters>
						<Parameter name="pv">the address of the buffer to put the data</Parameter>
						<Parameter name="cb">the maximum number of bytes to read from the stream</Parameter>
						<Parameter name="pcbRead">the actual number of bytes written to the buffer. This will be 0 at the end of the stream</Parameter>
					</Parameters>
					<Description>Reads upto cb bytes of data from the stream into the buffer. pcbRead will return the actual number of 
			bytes written to the buffer. this will be 0 when the end of the stream is reached.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Reset">
					<Short>reset the streams, moves the current position back to the start of the stream</Short>
					<Links/>
					<Parameters/>
					<Description>Resets the stream, moves the current read position back to the start of the stream.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>A simple stream reader interface that supports resetable streams (i.e. the stream position can be moved back to the start)</Description>
			<WhenToImpl>Implement this if you want to stream data to the transport</WhenToImpl>
			<WhenToCall>call this interface if you are writing a transport object that supports attachments</WhenToCall>
		</Interface>
		<Interface name="IHTTPTransportAdv2">
			<Short>Set advanced configuration options for the HTTP Transport</Short>
			<Links/>
			<Methods>
				<Method name="Option">
					<Short>get/set a named property</Short>
					<Links/>
					<Parameters/>
					<Description>
						<![CDATA[
Get or sets a named property for the HTTP transport.
Valid option names are
<ul>
<li>compression.enabled - compress the outgoing SOAP message, defaults to false</li>
<li>compression.level   - alter the level of compression, trades processing time vs message size, defaults to -1 (automatic), valid values are 0 (No Compression), 1 (Best speed), through to 9 (Best compression)</li> 
<li>compression.method  - chooses the compression method used to compress the outgoing message, defaults to DEFLATE, valid values are DEFLATE or GZIP</li>
<li>compression.accept  - controls whether the Accept-Encoding header appears in the request headers indicating that we can de-compress the response from the server, default is true</li>
<li>redirects.max		- how many redirects to follow before raising an error, defaults to 5</li>
<li>redirects.onpost    - should we follow redirects when doing an HTTP POST ?, defaults to false</li>
</ul>
]]>
					</Description>
					<ReturnValue>a HRESULT code</ReturnValue>
					<SampleCode>
						<![CDATA[
set t = CreateObject("PocketSOAP.HTTPTransport")
' compress the outgoing message
t.option("compression.enabled") = true
' rest of code goes here
]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interfaces allows for the adjustment of advanced HTTP features</Description>
			<WhenToImpl>There is a standard implementation of this, you don't need to implement it.</WhenToImpl>
			<WhenToCall>Call this when you want to adjust advanced features of the HTTP object (such as enabling compression)</WhenToCall>
		</Interface>
		<Interface name="ISoapDeSerializerDefaultHandler">
			<Short>This is an internal signalling interface</Short>
			<Links/>
			<Methods/>
			<Description>This is a signally interface used during the de-serialization process.</Description>
			<WhenToImpl>You should never implement this interface yourself</WhenToImpl>
			<WhenToCall>There are no methods to call on this interface</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryConfig3">
			<Short>allows for the configuration of understood SOAP Headers</Short>
			<Links/>
			<Methods><Method name="understoodHeader">
					<Short>Register a new Header QName that we understand</Short>
					<Links/>
					<Parameters>
						<Parameter name="NamespaceURI">The namespaceURI part of the QName</Parameter>
						<Parameter name="localName">The localname part of the QName</Parameter>
					</Parameters>
					<Description>Registers the QName of a SOAP Header element that we understand. If we deserialize a response that
			contains a soap header with mustUnderstand='1' which isn't in the list of understood headers, 
			then an error will be returned.</Description>
					<ReturnValue>S_OK</ReturnValue>
					<SampleCode><![CDATA[<pre><code>m_sf.understoodHeader "http://gxa.org/routing", "id"</code></pre>]]></SampleCode>
				</Method></Methods>
			<Description>Use this interface to configure the serializer factory with the soap headers that we understand.</Description>
			<WhenToImpl>There is a system provided implementation of this.</WhenToImpl>
			<WhenToCall>Call this when you add support for handling SOAP headers to your application</WhenToCall>
		</Interface>
		<Interface name="ISerializerFactoryHeaders">
			<Short>checks the serializer factory to see if we understand this soap header</Short>
			<Links/>
			<Methods><Method name="isUnderstood">
					<Short>checks the serializer factory to see if we understand this soap header</Short>
					<Links/>
					<Parameters><Parameter name="NamespaceURI">The NamespaceURI of the SOAP header element to check</Parameter>
						<Parameter name="localName">The localname of the SOAP header element to check</Parameter>
						<Parameter name="understood">set to VARIANT_TRUE if the serializer factory understand the header</Parameter>
					</Parameters>
					<Description>checks the serializer factory to see if we understand this soap header</Description>
					<ReturnValue>S_OK</ReturnValue>
					<SampleCode></SampleCode>
				</Method></Methods>
			<Description>This is used by the envelope parser to check for SOAP header handling when it deserializers a header with mustUnderstand='1' set.</Description>
			<WhenToImpl>There is a system provided implementation of this.</WhenToImpl>
			<WhenToCall>You shouldn't need to call this directly.</WhenToCall>
		</Interface>
		<Interface name="ISOAPNode12">
			<Short>This is the interface to a Node object that includes SOAP 1.2 support</Short>
			<Links/>
			<Methods>
				<Method name="role">
					<Short>This is the role attribute from the SOAP 1.2 spec, its very similar to the actor attribute in SOAP 1.1</Short>
					<Links/>
					<Parameters/>
					<Description><![CDATA[This is a string property which is the role attribute for a soap 1.2 header see <a href="http://www.w3.org/TR/2003/REC-soap12-part1-20030624/#soaproles">soap 1.2 spec</a>]]></Description>
					<ReturnValue>This is a string , e.g. http://www.w3.org/2003/05/soap-envelope/role/next</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="relay">
					<Short>This is the relay attributre from the SOAP 1.2 spec.</Short>
					<Links/>
					<Parameters/>
					<Description><![CDATA[This is a boolean property which is the role attribute for a soap 1.2 header, it affects how soap headers are handled by intermediaries, see <a href="http://www.w3.org/TR/2003/REC-soap12-part1-20030624/#relaysoapmsg">the soap 1.2 spec</a>]]></Description>
					<ReturnValue>true or false</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ref">
					<Short>This is the ref attribute from the SOAP 1.2 spec, its very similar to the href attribute in SOAP 1.1</Short>
					<Links>http://www.w3.org/TR/2003/REC-soap12-part2-20030624/#refattr</Links>
					<Parameters/>
					<Description>The ref attribute is used when serializing or deserializing object graphs using the soap encoding model.
Typically this is handled transparently for you by the PocketSOAP engine, you shouldn't need to work the the ref property directly.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface contains the SOAP 1.2 specific features for a SOAP node, the Role and Relay properties are used on soap headers and control
the targetting of soap headers to different intermediaries.</Description>
			<WhenToImpl>The CoSoapNode object provides an implementation of this interface, you shouldn't need to implement it.</WhenToImpl>
			<WhenToCall>Use this interface if you need to access SOAP 1.2 specific features of a soap node.</WhenToCall>
		</Interface>
		<Interface name="ISOAPNodeDisp">
			<Short>This is the scripting friendly version of the soap node objects methods</Short>
			<Links/>
			<Methods>
				<Method name="Name">
					<Short>see ISOAPNode::Name</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Namespace">
					<Short>see ISOAPNode::Namespace</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Type">
					<Short>see ISOAPNode::Type</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="TypeNS">
					<Short>see ISOAPNode::TypeNS</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Value">
					<Short>see ISOAPNode::Value</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ValueAs">
					<Short>see ISOAPNode::ValueAs</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="SerializerFactory">
					<Short>see ISOAPNode::SerializerFactory</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="root">
					<Short>see ISOAPNode::root</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="id">
					<Short>see ISOAPNode::id</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="href">
					<Short>see ISOAPNode::href</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="actor">
					<Short>see ISOAPNode::actor</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="mustUnderstand">
					<Short>see ISOAPNode::mustUnderstand</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="offset">
					<Short>see ISOAPNode::offset</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="position">
					<Short>see ISOAPNode::position</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="nil">
					<Short>see ISOAPNode::nil</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Nodes">
					<Short>see ISOAPNode::Nodes</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="EncodingStyle">
					<Short>see ISOAPNode2::EncodingStyle</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="explicitRoot">
					<Short>see ISOAPNode3::explicitRoot</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="role">
					<Short>see ISOAPNode12::role</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="relay">
					<Short>see ISOAPNode12::relay</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ref">
					<Short>see ISOAPNode12::ref</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface defintion drives the implemation of the IDispatch interface for the CoSoapNode object, it is an aggregation of all the methods from all the interfaces supported by the object.
You cannot call QueryInterface for this interface, its definition is only used to provide an implementation of IDispatch for scripting clients.</Description>
			<WhenToImpl></WhenToImpl>
			<WhenToCall></WhenToCall>
		</Interface>
		<Interface name="ISOAPEnvelope2">
			<Short>Exposes SOAP envelope version information</Short>
			<Links/>
			<Methods>
				<Method name="EnvelopeVersion">
					<Short>The namespace URI of the SOAP envelope.</Short>
					<Links/>
					<Parameters/>
					<Description>This property can be used to control the version of soap used for this particular envelope. To switch soap versions, change this property
to the namespace URI that represents the version of SOAP being used.</Description>
					<ReturnValue>a string value, either http://schemas.xmlsoap.org/soap/envelope/ for SOAP 1.1 or http://www.w3.org/2003/05/soap-envelope for SOAP 1.2</ReturnValue>
					<SampleCode><![CDATA[
dim env, t
set env = CreateObject("PocketSOAP.Envelope")
env.EnvelopeVersion = "http://www.w3.org/2003/05/soap-envelope"
env.SetMethod "echoString", "http://example.org/ts-tests"
env.Parameters.Create "inputString", "Hello World"

set t = CreateObject("PocketSOAP.HTTPTransport")
t.Send "http://www.whitemesa.net/soap12/test-rpc", env
env.Parse t]]>
					</SampleCode>
				</Method>
			</Methods>
			<Description>This interface allows access to version of soap being used for the envelope.</Description>
			<WhenToImpl>The standard PocketSOAP envelope object provides an implementation of this interface.</WhenToImpl>
			<WhenToCall>Call this to set the envelope to be a SOAP 1.2 envelope</WhenToCall>
		</Interface>
		<Interface name="ISerializerContext2">
			<Short>Additional context information about the envelope version</Short>
			<Links/>
			<Methods>
				<Method name="EnvelopeVersion">
					<Short>Allows the caller to determine the version of SOAP being used to generate the envelope during serialization</Short>
					<Links/>
					<Parameters/>
					<Description>Allows the caller to determine the version of SOAP being used to generate the envelope during serialization. If you are writing a custom serializer and need to know which version of SOAP you are being used from, call this method.</Description>
					<ReturnValue>This returns the namespace URI from the Envelope element, either http://schemas.xmlsoap.org/soap/envelope/ for SOAP 1.1 or http://www.w3.org/2003/05/soap-envelope for SOAP 1.2</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>Additional context information about the envelope version</Description>
			<WhenToImpl>The PocketSOAP serialization engine provides an implementation of this.</WhenToImpl>
			<WhenToCall>Call this from your custom serializer, if you need to find out what verision of soap is currently being serialized</WhenToCall>
		</Interface>
		<Interface name="IClassFactoryVersion">
			<Short>This is an internal helper interface used during creation of new envelopes</Short>
			<Links/>
			<Methods>
				<Method name="setVersion">
					<Short>Tell the envelope what version it should be</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This is an internal helper interface used during creation of new envelopes</Description>
			<WhenToImpl></WhenToImpl>
			<WhenToCall></WhenToCall>
		</Interface>
		<Interface name="ISOAPTransport2">
			<Short>This is a version of ISOAPTransport that supports a streaming interface for both send and receive</Short>
			<Links/>
			<Methods>
				<Method name="Send">
					<Short></Short>
					<Links/>
					<Parameters>
						<Parameter name="endpoint">///todo: describe this parameter</Parameter>
						<Parameter name="env">///todo: describe this parameter</Parameter>
					</Parameters>
					<Description>Send the specified envelope to the specified endpoint URL. The envelope can be a String (in which case it is assume to be a SOAP 1.1 envelope), or an Envelope object.</Description>
					<ReturnValue></ReturnValue>
					<SampleCode><![CDATA[
dim env, t
set env = CreateObject("PocketSOAP.Envelope")
env.EnvelopeVersion = "http://www.w3.org/2003/05/soap-envelope"
env.SetMethod "echoString", "http://example.org/ts-tests"
env.Parameters.Create "inputString", "Hello World"

set t = CreateObject("PocketSOAP.HTTPTransport")
t.Send "http://www.whitemesa.net/soap12/test-rpc", env
env.Parse t
]]>
					</SampleCode>
				</Method>
				<Method name="Receive">
					<Short>Get the response message from the previously sent message.</Short>
					<Links/>
					<Parameters>
						<Parameter name="characterEncoding">The transport should set this to the character encoding of the data returned in the response stream. How it gets this information is transport specific (e..g for HTTP, it should look at the charset attribute on the content type header)</Parameter>
						<Parameter name="responseStream">The response message as a stream. The callee should call Read on the resulting stream to access the response message.</Parameter>
					</Parameters>
					<Description>Get the response message from the previously sent message.</Description>
					<ReturnValue>A Stream the caller can call Read on to obtain the response message</ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This is the next generation of the ISOAPTransport interface, which provides a streaming interface to transports. </Description>
			<WhenToImpl>If your transport doesn't support a streaming interface, then you should implement the ISOAPTransport interface instead.</WhenToImpl>
			<WhenToCall></WhenToCall>
		</Interface>
		<Interface name="IHTTPTransportDisp">
			<Short>This is a scripting friendly interface to the http transport object.</Short>
			<Links/>
			<Methods>
				<Method name="Send">
					<Short>see ISOAPTransport2::Send</Short>
					<Links/>
					<Parameters>
						<Parameter name="endpoint"></Parameter>
						<Parameter name="Envelope"></Parameter>
					</Parameters>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Receive">
					<Short>see ISOAPTransport2::Receive</Short>
					<Links/>
					<Parameters>
						<Parameter name="characterEncoding"></Parameter>
						<Parameter name="Envelope"></Parameter>
					</Parameters>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="SOAPAction">
					<Short>see IHTTPTransport::SOAPAction</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Timeout">
					<Short>see IHTTPTransportAdv::Timeout</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="SetProxy">
					<Short>see IHTTPTransportAdv::SetProxy</Short>
					<Links/>
					<Parameters>
						<Parameter name="ProxyServer"></Parameter>
						<Parameter name="ProxyPort"></Parameter>
					</Parameters>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="NoProxy">
					<Short>see IHTTPTransportAdv::NoProxy</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Authentication">
					<Short>see IHTTPTransportAdv::Authentication</Short>
					<Links/>
					<Parameters>
						<Parameter name="username"></Parameter>
						<Parameter name="password"></Parameter>
					</Parameters>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="ProxyAuthentication">
					<Short>see IHTTPTransportAdv::ProxyAuthentication</Short>
					<Links/>
					<Parameters>
						<Parameter name="username"></Parameter>
						<Parameter name="password"></Parameter>
					</Parameters>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="StatusCode">
					<Short>see IHTTPTransportAdv::StatusCode</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="MaxRedirectDepth">
					<Short>see IHTTPTransportAdv::MaxRedirectDepth</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
				<Method name="Option">
					<Short>see IHTTPTransportAdv::Option</Short>
					<Links/>
					<Parameters/>
					<Description></Description>
					<ReturnValue></ReturnValue>
					<SampleCode></SampleCode>
				</Method>
			</Methods>
			<Description>This interface defintion drives the implemation of the IDispatch interface for the HTTPTransport object, it is an aggregation of all the methods from all the interfaces supported by the object.
You cannot call QueryInterface for this interface, its definition is only used to provide an implementation of IDispatch for scripting clients.</Description>
			<WhenToImpl></WhenToImpl>
			<WhenToCall></WhenToCall>
		</Interface>
	</Interfaces>
</Library>
